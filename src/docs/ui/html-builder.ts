/**
 * USD Documentation UI HTML Builder
 *
 * Generates the complete HTML for the USD documentation UI.
 * This module assembles all parts: HTML structure, CSS styles, and embedded JavaScript.
 *
 * Security Note: The embedded JavaScript uses innerHTML for rendering documentation
 * from trusted server-generated spec data. User-provided strings are escaped via esc().
 * This is safe because:
 * 1. The spec object is generated by our code (not user input)
 * 2. All user-visible text is escaped before rendering
 * 3. JSON data is escaped for script embedding to prevent XSS
 */

import type { UIConfig, UIGeneratorOptions } from './types.js'
import { generateStyles } from './styles.js'
import { escapeHtml, escapeJsonForScript, generateHeroBackgroundCSS } from './utils.js'

/**
 * Generate HTML for USD documentation UI
 */
export function generateUIHTML(options: UIGeneratorOptions): string {
  const { doc, basePath: _basePath, ui, tagGroups } = options

  const theme = ui?.theme ?? 'auto'
  const primaryColor = ui?.primaryColor ?? '#6366f1'
  const logo = ui?.logo
  const favicon = ui?.favicon
  const title = doc.info.title
  const hero = ui?.hero
  const sidebar = ui?.sidebar

  // Escape data for embedding in script tag (prevents XSS)
  const escapedSpec = escapeJsonForScript(doc)
  const escapedTagGroups = escapeJsonForScript(tagGroups ?? [])
  const escapedHero = escapeJsonForScript(hero ?? null)
  const escapedSidebar = escapeJsonForScript(sidebar ?? {})

  // Generate hero background CSS
  const heroBackgroundCSS = generateHeroBackgroundCSS(
    primaryColor,
    hero?.background,
    hero?.backgroundImage
  )

  // Generate CSS
  const styles = generateStyles({ primaryColor, heroBackgroundCSS })

  // Generate HTML
  return `<!DOCTYPE html>
<html lang="en" data-theme="${theme}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  ${favicon ? `<link rel="icon" href="${escapeHtml(favicon)}">` : ''}
  <style>
${styles}
  </style>
</head>
<body>
  ${generateHeroSection(hero, logo, title)}
  ${generateAppContainer(logo, title, sidebar)}
  <script>
${generateClientScript(escapedSpec, escapedTagGroups, escapedHero, escapedSidebar)}
  </script>
</body>
</html>`
}

/**
 * Generate hero section HTML
 */
function generateHeroSection(
  hero: UIConfig['hero'],
  logo: string | undefined,
  title: string
): string {
  if (!hero) return ''

  const buttonsHtml = hero.buttons && hero.buttons.length > 0
    ? `<div class="hero-buttons">
        ${hero.buttons.map(btn => `
          <a href="${btn.href || '#docs'}" class="hero-btn ${btn.primary ? 'hero-btn-primary' : 'hero-btn-secondary'}">
            ${escapeHtml(btn.text)}
          </a>
        `).join('')}
      </div>`
    : ''

  const quickLinksHtml = hero.quickLinks && hero.quickLinks.length > 0
    ? `<div class="hero-quicklinks">
        ${hero.quickLinks.map(link => `
          <a href="${escapeHtml(link.href)}" class="hero-quicklink">
            ${link.icon ? `<div class="hero-quicklink-icon">${escapeHtml(link.icon)}</div>` : ''}
            <div class="hero-quicklink-title">${escapeHtml(link.title)}</div>
            ${link.description ? `<div class="hero-quicklink-desc">${escapeHtml(link.description)}</div>` : ''}
          </a>
        `).join('')}
      </div>`
    : ''

  return `
  <header class="hero">
    <div class="hero-content">
      ${logo ? `<img class="hero-logo" src="${escapeHtml(logo)}" alt="Logo">` : ''}
      <h1 class="hero-title">${escapeHtml(hero.title || title)}</h1>
      ${hero.tagline ? `<p class="hero-tagline">${escapeHtml(hero.tagline)}</p>` : ''}
      ${buttonsHtml}
      ${quickLinksHtml}
    </div>
  </header>
  `
}

/**
 * Generate app container HTML
 */
function generateAppContainer(
  logo: string | undefined,
  title: string,
  sidebar: UIConfig['sidebar']
): string {
  return `
  <div class="app-container" id="docs">
    <aside class="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-logo">
          ${logo ? `<img src="${escapeHtml(logo)}" alt="Logo">` : ''}
          <h1>${escapeHtml(title)}</h1>
        </div>
        ${sidebar?.search !== false ? `
        <div class="sidebar-search">
          <input type="text" id="searchInput" placeholder="Search endpoints...">
        </div>
        ` : ''}
      </div>
      <div class="protocol-tabs" id="protocolTabs"></div>
      <nav class="sidebar-nav" id="sidebarNav"></nav>
    </aside>
    <main class="main" id="mainContent"></main>
  </div>
  `
}

/**
 * Generate client-side JavaScript
 * This is embedded in the HTML and handles all UI interactions
 */
function generateClientScript(
  escapedSpec: string,
  escapedTagGroups: string,
  escapedHero: string,
  escapedSidebar: string
): string {
  return `
    // Trusted data from server
    const spec = ${escapedSpec};
    const tagGroups = ${escapedTagGroups};
    const heroConfig = ${escapedHero};
    const sidebarConfig = ${escapedSidebar};

    // Helper to escape text for display
    function esc(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Simple markdown parser for descriptions
    function parseMarkdown(md) {
      if (!md) return '';
      let html = esc(md);
      var tick = String.fromCharCode(96); // backtick character

      // Code blocks (must be before inline code)
      var codeBlockRe = new RegExp(tick + tick + tick + '(\\\\w*)\\\\n([\\\\s\\\\S]*?)' + tick + tick + tick, 'g');
      html = html.replace(codeBlockRe, function(m, lang, code) {
        return '<pre class="md-code-block"><code class="language-' + (lang || 'text') + '">' + code.trim() + '</code></pre>';
      });

      // Inline code
      var inlineCodeRe = new RegExp(tick + '([^' + tick + ']+)' + tick, 'g');
      html = html.replace(inlineCodeRe, '<code class="md-inline-code">$1</code>');

      // Headers (## -> h2, ### -> h3, etc.)
      html = html.replace(/^#### (.+)$/gm, '<h4 class="md-h4">$1</h4>');
      html = html.replace(/^### (.+)$/gm, '<h3 class="md-h3">$1</h3>');
      html = html.replace(/^## (.+)$/gm, '<h2 class="md-h2">$1</h2>');

      // Bold
      html = html.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>');

      // Italic
      html = html.replace(/\\*([^*]+)\\*/g, '<em>$1</em>');

      // Tables
      html = html.replace(/^\\|(.+)\\|$/gm, function(match, content) {
        const cells = content.split('|').map(c => c.trim());
        // Check if it's a separator row
        if (cells.every(c => /^[-:]+$/.test(c))) {
          return ''; // Skip separator
        }
        const isHeader = match.indexOf('---') === -1 && html.indexOf(match) < html.indexOf('|---');
        const cellTag = 'td';
        return '<tr>' + cells.map(c => '<' + cellTag + '>' + c + '</' + cellTag + '>').join('') + '</tr>';
      });
      // Wrap table rows in table
      html = html.replace(/(<tr>[\\s\\S]*?<\\/tr>)+/g, function(rows) {
        return '<table class="md-table">' + rows + '</table>';
      });

      // Lists
      html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
      html = html.replace(/(<li>[\\s\\S]*?<\\/li>)+/g, function(items) {
        return '<ul class="md-list">' + items + '</ul>';
      });

      // Paragraphs (double newlines)
      html = html.replace(/\\n\\n+/g, '</p><p class="md-p">');
      html = '<p class="md-p">' + html + '</p>';

      // Clean up empty paragraphs
      html = html.replace(/<p class="md-p"><\\/p>/g, '');
      html = html.replace(/<p class="md-p">(\\s*<(?:h[234]|ul|table|pre)[^>]*>)/g, '$1');
      html = html.replace(/(<\\/(?:h[234]|ul|table|pre)>)\\s*<\\/p>/g, '$1');

      return html;
    }

    // Detect protocols with counts
    const protocolData = {};
    const xUsd = spec['x-usd'] || {};
    const wsSpec = xUsd.websocket;
    const streamsSpec = xUsd.streams;
    const jsonrpcSpec = xUsd.jsonrpc;
    const grpcSpec = xUsd.grpc;
    const tcpSpec = xUsd.tcp;
    const udpSpec = xUsd.udp;
    if (spec.paths) {
      let count = 0;
      Object.values(spec.paths).forEach(methods => {
        Object.keys(methods).forEach(m => {
          if (['get','post','put','patch','delete'].includes(m)) count++;
        });
      });
      if (count > 0) protocolData.http = count;
    }
    if (wsSpec?.channels) {
      protocolData.websocket = Object.keys(wsSpec.channels).length;
    }
    if (streamsSpec?.endpoints) {
      protocolData.streams = Object.keys(streamsSpec.endpoints).length;
    }
    if (jsonrpcSpec?.methods) {
      protocolData.jsonrpc = Object.keys(jsonrpcSpec.methods).length;
    }
    if (grpcSpec?.services) {
      let count = 0;
      Object.values(grpcSpec.services).forEach(s => {
        count += Object.keys(s.methods || {}).length;
      });
      if (count > 0) protocolData.grpc = count;
    }
    if (tcpSpec?.servers) {
      protocolData.tcp = Object.keys(tcpSpec.servers).length;
    }
    if (udpSpec?.endpoints) {
      protocolData.udp = Object.keys(udpSpec.endpoints).length;
    }

    const protocols = Object.keys(protocolData);
    let activeProtocol = protocols[0] || 'http';
    let searchQuery = '';

    // Search functionality
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.addEventListener('input', (e) => {
        searchQuery = e.target.value.toLowerCase();
        renderSidebar();
        renderContent();
      });
    }

    function renderProtocolTabs() {
      const container = document.getElementById('protocolTabs');
      container.textContent = '';
      protocols.forEach(p => {
        const btn = document.createElement('button');
        btn.className = 'protocol-tab' + (p === activeProtocol ? ' active' : '');
        const label = p.charAt(0).toUpperCase() + p.slice(1);
        const count = protocolData[p];
        btn.innerHTML = label + (sidebarConfig.showCounts !== false ? '<span class="count">' + count + '</span>' : '');
        btn.onclick = () => setProtocol(p);
        container.appendChild(btn);
      });
    }

    function setProtocol(protocol) {
      activeProtocol = protocol;
      renderProtocolTabs();
      renderSidebar();
      renderContent();
    }

    function renderSidebar() {
      const nav = document.getElementById('sidebarNav');
      nav.textContent = '';

      // Add Introduction link if there's a description (and not searching)
      if (!searchQuery && spec.info && spec.info.description) {
        const introLink = document.createElement('div');
        introLink.className = 'nav-item nav-item-intro';
        introLink.innerHTML = '<span class="nav-item-icon">ðŸ“–</span><span class="nav-item-text">Introduction</span>';
        introLink.onclick = () => {
          const el = document.getElementById('introduction');
          if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };
        nav.appendChild(introLink);
      }

      // Get endpoints for current protocol
      const endpoints = getEndpointsForProtocol(activeProtocol);

      // Filter by search
      const filtered = searchQuery
        ? endpoints.filter(e =>
            e.path.toLowerCase().includes(searchQuery) ||
            (e.summary || '').toLowerCase().includes(searchQuery) ||
            (e.description || '').toLowerCase().includes(searchQuery)
          )
        : endpoints;

      // Group by tags
      const tagMap = new Map();
      const untagged = [];

      filtered.forEach(ep => {
        const tags = ep.tags || ['Other'];
        if (tags.length === 0) {
          untagged.push(ep);
        } else {
          tags.forEach(tag => {
            if (!tagMap.has(tag)) tagMap.set(tag, []);
            tagMap.get(tag).push(ep);
          });
        }
      });

      // Use tagGroups if defined, otherwise auto-group by tags (sorted, Other last)
      const sortedTags = Array.from(tagMap.keys()).sort((a, b) => {
        if (a === 'Other') return 1;
        if (b === 'Other') return -1;
        return a.localeCompare(b);
      });
      const groups = tagGroups.length > 0 ? tagGroups : sortedTags.map(name => ({
        name,
        tags: [name],
        expanded: sidebarConfig.expandAll !== false
      }));

      groups.forEach((group, idx) => {
        const groupEndpoints = [];
        group.tags.forEach(tag => {
          const eps = tagMap.get(tag) || [];
          groupEndpoints.push(...eps);
        });

        if (groupEndpoints.length === 0) return;

        const groupEl = document.createElement('div');
        groupEl.className = 'tag-group' + (group.expanded === false ? ' collapsed' : '');

        const header = document.createElement('div');
        header.className = 'tag-group-header';
        header.innerHTML = '<span class="tag-group-arrow">â–¼</span>' +
          esc(group.name) +
          '<span class="tag-group-count">' + groupEndpoints.length + '</span>';
        header.onclick = () => groupEl.classList.toggle('collapsed');

        const items = document.createElement('div');
        items.className = 'tag-group-items';
        items.style.maxHeight = group.expanded === false ? '0' : (groupEndpoints.length * 50) + 'px';

        groupEndpoints.forEach(ep => {
          const item = document.createElement('div');
          item.className = 'nav-item';
          item.innerHTML = '<span class="nav-item-method ' + getMethodClass(ep.method) + '">' +
            esc(ep.method) + '</span><span class="nav-item-path">' + esc(ep.path) + '</span>';
          item.onclick = (e) => {
            e.stopPropagation();
            scrollToEndpoint(ep.id);
          };
          items.appendChild(item);
        });

        groupEl.appendChild(header);
        groupEl.appendChild(items);
        nav.appendChild(groupEl);
      });

      // Add untagged if any
      if (untagged.length > 0) {
        const groupEl = document.createElement('div');
        groupEl.className = 'tag-group';

        const header = document.createElement('div');
        header.className = 'tag-group-header';
        header.innerHTML = '<span class="tag-group-arrow">â–¼</span>Other<span class="tag-group-count">' + untagged.length + '</span>';
        header.onclick = () => groupEl.classList.toggle('collapsed');

        const items = document.createElement('div');
        items.className = 'tag-group-items';
        items.style.maxHeight = (untagged.length * 50) + 'px';

        untagged.forEach(ep => {
          const item = document.createElement('div');
          item.className = 'nav-item';
          item.innerHTML = '<span class="nav-item-method ' + getMethodClass(ep.method) + '">' +
            esc(ep.method) + '</span><span class="nav-item-path">' + esc(ep.path) + '</span>';
          item.onclick = (e) => {
            e.stopPropagation();
            scrollToEndpoint(ep.id);
          };
          items.appendChild(item);
        });

        groupEl.appendChild(header);
        groupEl.appendChild(items);
        nav.appendChild(groupEl);
      }
    }

    function getMethodClass(method) {
      const m = method.toLowerCase();
      if (m === 'get') return 'method-get';
      if (m === 'post') return 'method-post';
      if (m === 'put') return 'method-put';
      if (m === 'patch') return 'method-patch';
      if (m === 'delete') return 'method-delete';
      if (m === 'ws' || m === 'websocket') return 'method-ws';
      if (m === 'stream' || m === 'sse') return 'method-stream';
      if (m === 'rpc') return 'method-rpc';
      if (m === 'grpc' || m === 'unary') return 'method-grpc';
      return 'method-post';
    }

    function getEndpointsForProtocol(protocol) {
      const endpoints = [];
      let id = 0;

      if (protocol === 'http' && spec.paths) {
        Object.entries(spec.paths).forEach(([path, methods]) => {
          Object.entries(methods).forEach(([method, op]) => {
            if (!['get','post','put','patch','delete'].includes(method)) return;
            endpoints.push({
              id: 'ep-' + (id++),
              path,
              method: method.toUpperCase(),
              summary: op.summary,
              description: op.description,
              tags: op.tags || [],
              data: op
            });
          });
        });
      } else if (protocol === 'websocket' && wsSpec?.channels) {
        Object.entries(wsSpec.channels).forEach(([name, channel]) => {
          endpoints.push({
            id: 'ep-' + (id++),
            path: name,
            method: 'WS',
            summary: channel.description,
            tags: channel.tags || [],
            data: channel
          });
        });
      } else if (protocol === 'streams' && streamsSpec?.endpoints) {
        Object.entries(streamsSpec.endpoints).forEach(([name, endpoint]) => {
          endpoints.push({
            id: 'ep-' + (id++),
            path: name,
            method: endpoint.direction || 'STREAM',
            summary: endpoint.description,
            tags: endpoint.tags || [],
            data: endpoint
          });
        });
      } else if (protocol === 'jsonrpc' && jsonrpcSpec?.methods) {
        Object.entries(jsonrpcSpec.methods).forEach(([name, method]) => {
          endpoints.push({
            id: 'ep-' + (id++),
            path: name,
            method: 'RPC',
            summary: method.description,
            tags: method.tags || [],
            data: method
          });
        });
      } else if (protocol === 'grpc' && grpcSpec?.services) {
        Object.entries(grpcSpec.services).forEach(([serviceName, service]) => {
          Object.entries(service.methods || {}).forEach(([methodName, method]) => {
            const type = getGrpcMethodType(method);
            endpoints.push({
              id: 'ep-' + (id++),
              path: serviceName + '/' + methodName,
              method: type.toUpperCase(),
              summary: method.description,
              tags: service.tags || [],
              data: { service, method, serviceName, methodName }
            });
          });
        });
      } else if (protocol === 'tcp' && tcpSpec?.servers) {
        Object.entries(tcpSpec.servers).forEach(([name, server]) => {
          endpoints.push({
            id: 'ep-' + (id++),
            path: name,
            method: 'TCP',
            summary: server.description,
            tags: server.tags || [],
            data: server
          });
        });
      } else if (protocol === 'udp' && udpSpec?.endpoints) {
        Object.entries(udpSpec.endpoints).forEach(([name, endpoint]) => {
          endpoints.push({
            id: 'ep-' + (id++),
            path: name,
            method: 'UDP',
            summary: endpoint.description,
            tags: endpoint.tags || [],
            data: endpoint
          });
        });
      }

      return endpoints;
    }

    function scrollToEndpoint(id) {
      const el = document.getElementById(id);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        el.classList.add('expanded');
      }
    }

    function renderContent() {
      const main = document.getElementById('mainContent');
      main.textContent = '';

      // Render API introduction/description (only when not searching)
      if (!searchQuery && spec.info && spec.info.description) {
        const intro = document.createElement('div');
        intro.className = 'intro-section';
        intro.id = 'introduction';

        const content = document.createElement('div');
        content.className = 'markdown-content';
        content.innerHTML = parseMarkdown(spec.info.description);
        intro.appendChild(content);
        main.appendChild(intro);
      }

      const endpoints = getEndpointsForProtocol(activeProtocol);
      const filtered = searchQuery
        ? endpoints.filter(e =>
            e.path.toLowerCase().includes(searchQuery) ||
            (e.summary || '').toLowerCase().includes(searchQuery)
          )
        : endpoints;

      if (filtered.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'section';
        empty.innerHTML = '<p style="color: var(--text-muted);">No endpoints found' +
          (searchQuery ? ' matching "' + esc(searchQuery) + '"' : '') + '</p>';
        main.appendChild(empty);
        return;
      }

      // Group by tags for display
      const tagMap = new Map();
      filtered.forEach(ep => {
        const tag = (ep.tags && ep.tags[0]) || 'Endpoints';
        if (!tagMap.has(tag)) tagMap.set(tag, []);
        tagMap.get(tag).push(ep);
      });

      tagMap.forEach((eps, tag) => {
        const section = document.createElement('div');
        section.className = 'section';

        const title = document.createElement('h2');
        title.className = 'section-title';
        title.textContent = tag;
        section.appendChild(title);

        // Find tag description from spec
        const tagDef = (spec.tags || []).find(t => t.name === tag);
        if (tagDef?.description) {
          const desc = document.createElement('p');
          desc.className = 'section-desc';
          desc.textContent = tagDef.description;
          section.appendChild(desc);
        }

        eps.forEach(ep => {
          const card = createEndpointCard(ep);
          section.appendChild(card);
        });

        main.appendChild(section);
      });
    }

    // ========== TRY IT OUT ==========

    function renderTryItOut(ep) {
      const container = document.createElement('div');
      container.className = 'try-it-out';

      // Header
      const header = document.createElement('div');
      header.className = 'try-it-header';
      header.innerHTML = '<span class="try-it-title">Try it out</span>' +
        '<button class="try-it-toggle" type="button">â–¼</button>';
      header.onclick = () => container.classList.toggle('collapsed');
      container.appendChild(header);

      // Form content
      const form = document.createElement('div');
      form.className = 'try-it-form';

      const data = ep.data || {};
      const params = data.parameters || [];
      const baseUrl = (spec.servers && spec.servers[0]?.url) || 'http://localhost:3000';

      // Server URL
      const urlGroup = document.createElement('div');
      urlGroup.className = 'try-it-group';
      urlGroup.innerHTML = '<label class="try-it-label">Server</label>' +
        '<input type="text" class="try-it-input try-it-server" value="' + esc(baseUrl) + '">';
      form.appendChild(urlGroup);

      // Path parameters
      const pathParams = params.filter(p => p.in === 'path');
      if (pathParams.length > 0) {
        const section = document.createElement('div');
        section.className = 'try-it-section';
        section.innerHTML = '<div class="try-it-section-title">Path Parameters</div>';
        pathParams.forEach(p => {
          const group = document.createElement('div');
          group.className = 'try-it-group';
          const schema = p.schema || {};
          const placeholder = schema.example || schema.default || p.name;
          group.innerHTML = '<label class="try-it-label">' + esc(p.name) +
            (p.required ? ' <span class="try-it-required">*</span>' : '') + '</label>' +
            '<input type="text" class="try-it-input try-it-path-param" ' +
            'data-name="' + esc(p.name) + '" placeholder="' + esc(String(placeholder)) + '"' +
            (schema.default !== undefined ? ' value="' + esc(String(schema.default)) + '"' : '') + '>';
          section.appendChild(group);
        });
        form.appendChild(section);
      }

      // Query parameters
      const queryParams = params.filter(p => p.in === 'query');
      if (queryParams.length > 0) {
        const section = document.createElement('div');
        section.className = 'try-it-section';
        section.innerHTML = '<div class="try-it-section-title">Query Parameters</div>';
        queryParams.forEach(p => {
          const group = document.createElement('div');
          group.className = 'try-it-group';
          const schema = p.schema || {};
          const placeholder = schema.example || schema.default || '';
          group.innerHTML = '<label class="try-it-label">' + esc(p.name) +
            (p.required ? ' <span class="try-it-required">*</span>' : '') + '</label>' +
            '<input type="text" class="try-it-input try-it-query-param" ' +
            'data-name="' + esc(p.name) + '" placeholder="' + esc(String(placeholder)) + '"' +
            (schema.default !== undefined ? ' value="' + esc(String(schema.default)) + '"' : '') + '>';
          section.appendChild(group);
        });
        form.appendChild(section);
      }

      // Header parameters
      const headerParams = params.filter(p => p.in === 'header');
      if (headerParams.length > 0) {
        const section = document.createElement('div');
        section.className = 'try-it-section';
        section.innerHTML = '<div class="try-it-section-title">Headers</div>';
        headerParams.forEach(p => {
          const group = document.createElement('div');
          group.className = 'try-it-group';
          const schema = p.schema || {};
          group.innerHTML = '<label class="try-it-label">' + esc(p.name) +
            (p.required ? ' <span class="try-it-required">*</span>' : '') + '</label>' +
            '<input type="text" class="try-it-input try-it-header-param" ' +
            'data-name="' + esc(p.name) + '"' +
            (schema.default !== undefined ? ' value="' + esc(String(schema.default)) + '"' : '') + '>';
          section.appendChild(group);
        });
        form.appendChild(section);
      }

      // Request body
      if (data.requestBody) {
        const section = document.createElement('div');
        section.className = 'try-it-section';
        section.innerHTML = '<div class="try-it-section-title">Request Body</div>';

        const content = data.requestBody.content || {};
        const contentType = Object.keys(content)[0] || 'application/json';
        const mediaType = content[contentType] || {};

        // Build example from schema
        let exampleBody = {};
        if (mediaType.schema) {
          exampleBody = buildExampleFromSchema(mediaType.schema) || {};
        }

        const textarea = document.createElement('textarea');
        textarea.className = 'try-it-body';
        textarea.placeholder = 'Request body (JSON)';
        textarea.value = JSON.stringify(exampleBody, null, 2);
        section.appendChild(textarea);
        form.appendChild(section);
      }

      // Send button
      const actions = document.createElement('div');
      actions.className = 'try-it-actions';
      const sendBtn = document.createElement('button');
      sendBtn.type = 'button';
      sendBtn.className = 'try-it-send';
      sendBtn.textContent = 'Send Request';
      actions.appendChild(sendBtn);
      form.appendChild(actions);

      // Response area
      const responseArea = document.createElement('div');
      responseArea.className = 'try-it-response';
      responseArea.style.display = 'none';
      form.appendChild(responseArea);

      container.appendChild(form);

      // Handle send
      sendBtn.onclick = async () => {
        sendBtn.disabled = true;
        sendBtn.textContent = 'Sending...';
        responseArea.style.display = 'block';
        responseArea.innerHTML = '<div class="try-it-loading">Loading...</div>';

        try {
          // Build URL
          const serverInput = form.querySelector('.try-it-server');
          let url = serverInput.value + ep.path;

          // Replace path params
          form.querySelectorAll('.try-it-path-param').forEach(input => {
            const name = input.getAttribute('data-name');
            const value = input.value || input.placeholder;
            url = url.replace('{' + name + '}', encodeURIComponent(value));
            url = url.replace(':' + name, encodeURIComponent(value));
          });

          // Add query params
          const queryParts = [];
          form.querySelectorAll('.try-it-query-param').forEach(input => {
            const name = input.getAttribute('data-name');
            const value = input.value;
            if (value) {
              queryParts.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
            }
          });
          if (queryParts.length > 0) {
            url += '?' + queryParts.join('&');
          }

          // Build headers
          const headers = {};
          form.querySelectorAll('.try-it-header-param').forEach(input => {
            const name = input.getAttribute('data-name');
            const value = input.value;
            if (value) {
              headers[name] = value;
            }
          });

          // Build request options
          const options = {
            method: ep.method.toUpperCase(),
            headers: headers,
          };

          // Add body for POST/PUT/PATCH
          if (['POST', 'PUT', 'PATCH'].includes(options.method)) {
            const bodyTextarea = form.querySelector('.try-it-body');
            if (bodyTextarea && bodyTextarea.value) {
              options.headers['Content-Type'] = 'application/json';
              options.body = bodyTextarea.value;
            }
          }

          // Send request
          const startTime = performance.now();
          const response = await fetch(url, options);
          const endTime = performance.now();
          const duration = Math.round(endTime - startTime);

          // Get response body
          let responseBody = '';
          const contentType = response.headers.get('content-type') || '';
          if (contentType.includes('application/json')) {
            try {
              const json = await response.json();
              responseBody = JSON.stringify(json, null, 2);
            } catch (e) {
              responseBody = await response.text();
            }
          } else {
            responseBody = await response.text();
          }

          // Display response
          const statusClass = response.ok ? 'status-2xx' :
                             response.status >= 400 && response.status < 500 ? 'status-4xx' : 'status-5xx';

          responseArea.innerHTML =
            '<div class="try-it-response-header">' +
            '<span class="try-it-response-status ' + statusClass + '">' + response.status + ' ' + response.statusText + '</span>' +
            '<span class="try-it-response-time">' + duration + 'ms</span>' +
            '</div>' +
            '<div class="try-it-response-headers">' +
            '<div class="try-it-section-title">Response Headers</div>' +
            '<pre class="try-it-response-headers-pre">' + formatResponseHeaders(response) + '</pre>' +
            '</div>' +
            '<div class="try-it-response-body">' +
            '<div class="try-it-section-title">Response Body</div>' +
            '<pre class="sample-json"><code>' + (contentType.includes('json') ? syntaxHighlightJSON(responseBody) : esc(responseBody)) + '</code></pre>' +
            '</div>';
        } catch (error) {
          responseArea.innerHTML =
            '<div class="try-it-error">' +
            '<strong>Error:</strong> ' + esc(error.message) +
            '</div>';
        } finally {
          sendBtn.disabled = false;
          sendBtn.textContent = 'Send Request';
        }
      };

      return container;
    }

    function formatResponseHeaders(response) {
      const lines = [];
      response.headers.forEach((value, key) => {
        lines.push(esc(key) + ': ' + esc(value));
      });
      return lines.join('\\n');
    }

    // ========== TRY IT OUT WEBSOCKET ==========

    function renderTryItOutWebSocket(ep) {
      const container = document.createElement('div');
      container.className = 'try-it-out try-it-ws';

      // Header
      const header = document.createElement('div');
      header.className = 'try-it-header';
      header.innerHTML = '<span class="try-it-title">WebSocket Console</span>' +
        '<button class="try-it-toggle" type="button">â–¼</button>';
      header.onclick = () => container.classList.toggle('collapsed');
      container.appendChild(header);

      // Form content
      const form = document.createElement('div');
      form.className = 'try-it-form';

      const data = ep.data || {};
      const baseUrl = (spec.servers && spec.servers[0]?.url) || 'http://localhost:3000';
      const wsUrl = baseUrl.replace(/^http/, 'ws') + (ep.path || '/' + ep.id);

      // WebSocket URL
      const urlGroup = document.createElement('div');
      urlGroup.className = 'try-it-group';
      urlGroup.innerHTML = '<label class="try-it-label">WebSocket URL</label>' +
        '<input type="text" class="try-it-input try-it-ws-url" value="' + esc(wsUrl) + '">';
      form.appendChild(urlGroup);

      // Connection parameters (if any)
      if (data.parameters && Object.keys(data.parameters).length > 0) {
        const section = document.createElement('div');
        section.className = 'try-it-section';
        section.innerHTML = '<div class="try-it-section-title">Parameters</div>';
        Object.entries(data.parameters).forEach(([name, param]) => {
          const group = document.createElement('div');
          group.className = 'try-it-group';
          group.innerHTML = '<label class="try-it-label">' + esc(name) +
            (param.required ? ' <span class="try-it-required">*</span>' : '') + '</label>' +
            '<input type="text" class="try-it-input try-it-ws-param" ' +
            'data-name="' + esc(name) + '" placeholder="' + esc(param.description || '') + '">';
          section.appendChild(group);
        });
        form.appendChild(section);
      }

      // Message to send
      const msgSection = document.createElement('div');
      msgSection.className = 'try-it-section';
      msgSection.innerHTML = '<div class="try-it-section-title">Send Message</div>';

      // Build example message from subscribe/publish schema
      let exampleMsg = {};
      if (data.subscribe?.message?.payload) {
        exampleMsg = buildExampleFromSchema(data.subscribe.message.payload);
      } else if (data.publish?.message?.payload) {
        exampleMsg = buildExampleFromSchema(data.publish.message.payload);
      }

      const textarea = document.createElement('textarea');
      textarea.className = 'try-it-body try-it-ws-message';
      textarea.placeholder = 'Message to send (JSON)';
      textarea.value = JSON.stringify(exampleMsg || {}, null, 2);
      msgSection.appendChild(textarea);
      form.appendChild(msgSection);

      // Actions
      const actions = document.createElement('div');
      actions.className = 'try-it-actions try-it-ws-actions';

      const connectBtn = document.createElement('button');
      connectBtn.type = 'button';
      connectBtn.className = 'try-it-send try-it-ws-connect';
      connectBtn.textContent = 'Connect';

      const sendBtn = document.createElement('button');
      sendBtn.type = 'button';
      sendBtn.className = 'try-it-send try-it-ws-send';
      sendBtn.textContent = 'Send';
      sendBtn.disabled = true;
      sendBtn.style.marginTop = '8px';

      actions.appendChild(connectBtn);
      actions.appendChild(sendBtn);
      form.appendChild(actions);

      // Status indicator
      const statusDiv = document.createElement('div');
      statusDiv.className = 'try-it-ws-status';
      statusDiv.innerHTML = '<span class="ws-status-dot"></span><span class="ws-status-text">Disconnected</span>';
      form.appendChild(statusDiv);

      // Messages log
      const logSection = document.createElement('div');
      logSection.className = 'try-it-section try-it-ws-log-section';
      logSection.style.display = 'none';
      logSection.innerHTML = '<div class="try-it-section-title">Messages <button class="try-it-ws-clear" type="button">Clear</button></div>';
      const log = document.createElement('div');
      log.className = 'try-it-ws-log';
      logSection.appendChild(log);
      form.appendChild(logSection);

      container.appendChild(form);

      // WebSocket connection logic
      let ws = null;

      const updateStatus = (connected) => {
        const dot = statusDiv.querySelector('.ws-status-dot');
        const text = statusDiv.querySelector('.ws-status-text');
        if (connected) {
          dot.classList.add('connected');
          text.textContent = 'Connected';
          connectBtn.textContent = 'Disconnect';
          sendBtn.disabled = false;
          logSection.style.display = 'block';
        } else {
          dot.classList.remove('connected');
          text.textContent = 'Disconnected';
          connectBtn.textContent = 'Connect';
          sendBtn.disabled = true;
        }
      };

      const addMessage = (type, content) => {
        const msg = document.createElement('div');
        msg.className = 'try-it-ws-msg try-it-ws-msg-' + type;
        const time = new Date().toLocaleTimeString();
        msg.innerHTML = '<span class="ws-msg-time">' + time + '</span>' +
          '<span class="ws-msg-type">' + type + '</span>' +
          '<pre class="ws-msg-content">' + esc(typeof content === 'string' ? content : JSON.stringify(content, null, 2)) + '</pre>';
        log.appendChild(msg);
        log.scrollTop = log.scrollHeight;
      };

      connectBtn.onclick = () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close();
          return;
        }

        let url = form.querySelector('.try-it-ws-url').value;

        // Add parameters to URL
        const params = [];
        form.querySelectorAll('.try-it-ws-param').forEach(input => {
          const name = input.getAttribute('data-name');
          const value = input.value;
          if (value) {
            params.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
          }
        });
        if (params.length > 0) {
          url += (url.includes('?') ? '&' : '?') + params.join('&');
        }

        try {
          ws = new WebSocket(url);

          ws.onopen = () => {
            updateStatus(true);
            addMessage('system', 'Connected to ' + url);
          };

          ws.onmessage = (event) => {
            let data = event.data;
            try {
              data = JSON.parse(data);
            } catch (e) {}
            addMessage('received', data);
          };

          ws.onclose = (event) => {
            updateStatus(false);
            addMessage('system', 'Disconnected (code: ' + event.code + ')');
          };

          ws.onerror = () => {
            addMessage('error', 'Connection error');
          };
        } catch (err) {
          addMessage('error', err.message);
        }
      };

      sendBtn.onclick = () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const message = form.querySelector('.try-it-ws-message').value;
        ws.send(message);
        addMessage('sent', message);
      };

      logSection.querySelector('.try-it-ws-clear').onclick = () => {
        log.innerHTML = '';
      };

      return container;
    }

    // ========== TRY IT OUT STREAMS (SSE/EventSource) ==========

    function renderTryItOutStreams(ep) {
      const container = document.createElement('div');
      container.className = 'try-it-out try-it-sse';

      // Header
      const header = document.createElement('div');
      header.className = 'try-it-header';
      header.innerHTML = '<span class="try-it-title">Stream Console</span>' +
        '<button class="try-it-toggle" type="button">â–¼</button>';
      header.onclick = () => container.classList.toggle('collapsed');
      container.appendChild(header);

      // Form content
      const form = document.createElement('div');
      form.className = 'try-it-form';

      const data = ep.data || {};
      const baseUrl = (spec.servers && spec.servers[0]?.url) || 'http://localhost:3000';
      const streamUrl = baseUrl + (ep.path || '/' + ep.id);

      // Stream URL
      const urlGroup = document.createElement('div');
      urlGroup.className = 'try-it-group';
      urlGroup.innerHTML = '<label class="try-it-label">Stream URL</label>' +
        '<input type="text" class="try-it-input try-it-sse-url" value="' + esc(streamUrl) + '">';
      form.appendChild(urlGroup);

      // Query parameters (if any)
      if (data.parameters && Object.keys(data.parameters).length > 0) {
        const section = document.createElement('div');
        section.className = 'try-it-section';
        section.innerHTML = '<div class="try-it-section-title">Parameters</div>';
        Object.entries(data.parameters).forEach(([name, param]) => {
          const group = document.createElement('div');
          group.className = 'try-it-group';
          group.innerHTML = '<label class="try-it-label">' + esc(name) +
            (param.required ? ' <span class="try-it-required">*</span>' : '') + '</label>' +
            '<input type="text" class="try-it-input try-it-sse-param" ' +
            'data-name="' + esc(name) + '" placeholder="' + esc(param.description || '') + '">';
          section.appendChild(group);
        });
        form.appendChild(section);
      }

      // Actions
      const actions = document.createElement('div');
      actions.className = 'try-it-actions try-it-sse-actions';

      const subscribeBtn = document.createElement('button');
      subscribeBtn.type = 'button';
      subscribeBtn.className = 'try-it-send try-it-sse-subscribe';
      subscribeBtn.textContent = 'Subscribe';

      actions.appendChild(subscribeBtn);
      form.appendChild(actions);

      // Status indicator
      const statusDiv = document.createElement('div');
      statusDiv.className = 'try-it-sse-status';
      statusDiv.innerHTML = '<span class="sse-status-dot"></span><span class="sse-status-text">Disconnected</span>';
      form.appendChild(statusDiv);

      // Event types filter (shows received event types)
      const filterSection = document.createElement('div');
      filterSection.className = 'try-it-section try-it-sse-filter-section';
      filterSection.style.display = 'none';
      filterSection.innerHTML = '<div class="try-it-section-title">Event Types</div>' +
        '<div class="try-it-sse-filter"></div>';
      form.appendChild(filterSection);

      // Events log
      const logSection = document.createElement('div');
      logSection.className = 'try-it-section try-it-sse-log-section';
      logSection.style.display = 'none';
      logSection.innerHTML = '<div class="try-it-section-title">Events <span class="sse-event-count"></span><button class="try-it-sse-clear" type="button">Clear</button></div>';
      const log = document.createElement('div');
      log.className = 'try-it-sse-log';
      logSection.appendChild(log);
      form.appendChild(logSection);

      container.appendChild(form);

      // EventSource connection logic
      let eventSource = null;
      let eventCount = 0;
      const eventTypes = new Set();

      const updateStatus = (connected, connecting) => {
        const dot = statusDiv.querySelector('.sse-status-dot');
        const text = statusDiv.querySelector('.sse-status-text');
        dot.classList.remove('connected', 'connecting');
        if (connected) {
          dot.classList.add('connected');
          text.textContent = 'Connected';
          subscribeBtn.textContent = 'Unsubscribe';
          logSection.style.display = 'block';
        } else if (connecting) {
          dot.classList.add('connecting');
          text.textContent = 'Connecting...';
          subscribeBtn.textContent = 'Cancel';
        } else {
          text.textContent = 'Disconnected';
          subscribeBtn.textContent = 'Subscribe';
        }
      };

      const updateEventCount = () => {
        const countEl = logSection.querySelector('.sse-event-count');
        countEl.textContent = '(' + eventCount + ')';
      };

      const addEvent = (type, data, lastEventId) => {
        eventCount++;
        updateEventCount();

        // Track event type
        if (!eventTypes.has(type)) {
          eventTypes.add(type);
          updateFilterSection();
        }

        const event = document.createElement('div');
        event.className = 'try-it-sse-event' + (type === 'error' ? ' try-it-sse-event-error' : '');
        event.setAttribute('data-type', type);
        const time = new Date().toLocaleTimeString();

        let dataStr = data;
        try {
          const parsed = JSON.parse(data);
          dataStr = JSON.stringify(parsed, null, 2);
        } catch (e) {}

        event.innerHTML = '<div class="sse-event-header">' +
          '<span class="sse-event-time">' + time + '</span>' +
          '<span class="sse-event-type">' + esc(type || 'message') + '</span>' +
          (lastEventId ? '<span class="sse-event-id">id: ' + esc(lastEventId) + '</span>' : '') +
          '</div>' +
          '<pre class="sse-event-data">' + esc(dataStr) + '</pre>';
        log.appendChild(event);
        log.scrollTop = log.scrollHeight;
      };

      const updateFilterSection = () => {
        if (eventTypes.size === 0) {
          filterSection.style.display = 'none';
          return;
        }
        filterSection.style.display = 'block';
        const filterContainer = filterSection.querySelector('.try-it-sse-filter');
        filterContainer.innerHTML = '';
        eventTypes.forEach(type => {
          const badge = document.createElement('span');
          badge.className = 'sse-type-badge';
          badge.textContent = type || 'message';
          badge.onclick = () => {
            badge.classList.toggle('inactive');
            const show = !badge.classList.contains('inactive');
            log.querySelectorAll('.try-it-sse-event[data-type="' + type + '"]').forEach(el => {
              el.style.display = show ? 'block' : 'none';
            });
          };
          filterContainer.appendChild(badge);
        });
      };

      subscribeBtn.onclick = () => {
        if (eventSource) {
          eventSource.close();
          eventSource = null;
          updateStatus(false, false);
          return;
        }

        let url = form.querySelector('.try-it-sse-url').value;

        // Add parameters to URL
        const params = [];
        form.querySelectorAll('.try-it-sse-param').forEach(input => {
          const name = input.getAttribute('data-name');
          const value = input.value;
          if (value) {
            params.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
          }
        });
        if (params.length > 0) {
          url += (url.includes('?') ? '&' : '?') + params.join('&');
        }

        updateStatus(false, true);

        try {
          eventSource = new EventSource(url);

          eventSource.onopen = () => {
            updateStatus(true, false);
            addEvent('system', 'Connected to ' + url, null);
          };

          eventSource.onmessage = (e) => {
            addEvent('message', e.data, e.lastEventId);
          };

          // Listen for named events from spec
          const events = data.events || [];
          events.forEach(eventName => {
            eventSource.addEventListener(eventName, (e) => {
              addEvent(eventName, e.data, e.lastEventId);
            });
          });

          eventSource.onerror = () => {
            if (eventSource.readyState === EventSource.CLOSED) {
              addEvent('error', 'Connection closed', null);
              updateStatus(false, false);
              eventSource = null;
            } else {
              addEvent('error', 'Connection error (reconnecting...)', null);
            }
          };
        } catch (err) {
          addEvent('error', err.message, null);
          updateStatus(false, false);
        }
      };

      logSection.querySelector('.try-it-sse-clear').onclick = () => {
        log.innerHTML = '';
        eventCount = 0;
        updateEventCount();
      };

      return container;
    }

    function createEndpointCard(ep) {
      const section = document.createElement('div');
      section.className = 'endpoint-section';
      section.id = ep.id;

      // Header with method + path
      const header = document.createElement('div');
      header.className = 'endpoint-header';

      const methodPath = document.createElement('div');
      methodPath.className = 'endpoint-method-path';

      const badge = document.createElement('span');
      badge.className = 'badge badge-' + ep.method.toLowerCase();
      badge.textContent = ep.method;

      const path = document.createElement('span');
      path.className = 'endpoint-path';
      path.textContent = ep.path;

      methodPath.appendChild(badge);
      methodPath.appendChild(path);
      header.appendChild(methodPath);

      section.appendChild(header);

      // Title (operation summary)
      if (ep.summary) {
        const title = document.createElement('h3');
        title.className = 'endpoint-title';
        title.textContent = ep.summary;
        section.appendChild(title);
      }

      // Description if available (rendered as markdown)
      const opData = ep.data;
      if (opData?.description && opData.description !== ep.summary) {
        const desc = document.createElement('div');
        desc.className = 'endpoint-description markdown-content';
        desc.innerHTML = parseMarkdown(opData.description);
        section.appendChild(desc);
      }

      // Two-column content layout
      const content = document.createElement('div');
      content.className = 'endpoint-content';

      const leftCol = document.createElement('div');
      leftCol.className = 'endpoint-left';

      const rightCol = document.createElement('div');
      rightCol.className = 'endpoint-right';

      // Render details into left column
      leftCol.appendChild(renderEndpointDetails(ep));

      // Render right column content (Request + Response samples)
      rightCol.appendChild(renderRightPanelContent(ep));

      content.appendChild(leftCol);
      content.appendChild(rightCol);
      section.appendChild(content);

      return section;
    }

    // ========== RIGHT PANEL CONTENT (Request + Response Samples) ==========

    function renderRightPanelContent(ep) {
      const container = document.createElement('div');
      container.className = 'right-panel-content';

      if (activeProtocol === 'http') {
        // Try It Out section
        const tryItSection = document.createElement('div');
        tryItSection.className = 'right-section try-it-section';
        tryItSection.appendChild(renderTryItOut(ep));
        container.appendChild(tryItSection);

        // Request section
        const requestSection = document.createElement('div');
        requestSection.className = 'right-section request-section';

        const requestHeader = document.createElement('div');
        requestHeader.className = 'right-section-header';
        requestHeader.textContent = 'Request samples';
        requestSection.appendChild(requestHeader);

        // Add curl example
        requestSection.appendChild(renderCodeExample(ep));
        container.appendChild(requestSection);

        // Response samples section
        const data = ep.data || {};
        const responses = data.responses || {};
        const statusCodes = Object.keys(responses).sort();

        if (statusCodes.length > 0) {
          const responseSection = document.createElement('div');
          responseSection.className = 'right-section response-samples-section';

          const responseHeader = document.createElement('div');
          responseHeader.className = 'right-section-header';
          responseHeader.textContent = 'Response samples';
          responseSection.appendChild(responseHeader);

          // Tabs for status codes
          const tabsContainer = document.createElement('div');
          tabsContainer.className = 'sample-tabs';

          const contentContainer = document.createElement('div');
          contentContainer.className = 'sample-contents';

          statusCodes.forEach((status, idx) => {
            // Tab button
            const tab = document.createElement('button');
            tab.className = 'sample-tab' + (idx === 0 ? ' active' : '');
            const statusClass = status.startsWith('2') ? 'status-2xx' :
                               status.startsWith('4') ? 'status-4xx' :
                               status.startsWith('5') ? 'status-5xx' : '';
            tab.innerHTML = '<span class="tab-status ' + statusClass + '">' + esc(status) + '</span>';
            tab.onclick = () => {
              // Remove active from all tabs
              tabsContainer.querySelectorAll('.sample-tab').forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              // Show corresponding content
              contentContainer.querySelectorAll('.sample-content').forEach((c, i) => {
                c.style.display = i === idx ? 'block' : 'none';
              });
            };
            tabsContainer.appendChild(tab);

            // Content for this status
            const content = document.createElement('div');
            content.className = 'sample-content';
            content.style.display = idx === 0 ? 'block' : 'none';

            const response = responses[status];
            const respContent = response.content || {};
            const contentType = Object.keys(respContent)[0];

            if (contentType && respContent[contentType]) {
              const mediaType = respContent[contentType];
              let example = null;

              // Try to get example from various places
              if (mediaType.example) {
                example = mediaType.example;
              } else if (mediaType.examples) {
                const firstExKey = Object.keys(mediaType.examples)[0];
                if (firstExKey && mediaType.examples[firstExKey]) {
                  example = mediaType.examples[firstExKey].value;
                }
              } else if (mediaType.schema) {
                // Build example from schema
                example = buildExampleFromSchema(mediaType.schema);
              }

              if (example !== null) {
                const pre = document.createElement('pre');
                pre.className = 'sample-json';
                const code = document.createElement('code');
                code.innerHTML = syntaxHighlightJSON(JSON.stringify(example, null, 2));
                pre.appendChild(code);
                content.appendChild(pre);
              } else {
                const noExample = document.createElement('div');
                noExample.className = 'no-example';
                noExample.textContent = 'No example available';
                content.appendChild(noExample);
              }
            } else {
              // No content, just description
              const desc = document.createElement('div');
              desc.className = 'response-desc-only';
              desc.textContent = response.description || 'No content';
              content.appendChild(desc);
            }

            contentContainer.appendChild(content);
          });

          responseSection.appendChild(tabsContainer);
          responseSection.appendChild(contentContainer);
          container.appendChild(responseSection);
        }
      } else if (activeProtocol === 'websocket') {
        // WebSocket Try It Out
        const tryItSection = document.createElement('div');
        tryItSection.className = 'right-section try-it-section';
        tryItSection.appendChild(renderTryItOutWebSocket(ep));
        container.appendChild(tryItSection);

        // Request samples (wscat)
        const requestSection = document.createElement('div');
        requestSection.className = 'right-section request-section';
        const requestHeader = document.createElement('div');
        requestHeader.className = 'right-section-header';
        requestHeader.textContent = 'Request samples';
        requestSection.appendChild(requestHeader);
        requestSection.appendChild(renderCodeExampleWebSocket(ep));
        container.appendChild(requestSection);
      } else if (activeProtocol === 'streams') {
        // Streams (SSE) Try It Out
        const tryItSection = document.createElement('div');
        tryItSection.className = 'right-section try-it-section';
        tryItSection.appendChild(renderTryItOutStreams(ep));
        container.appendChild(tryItSection);

        // Request samples (curl, EventSource)
        const requestSection = document.createElement('div');
        requestSection.className = 'right-section request-section';
        const requestHeader = document.createElement('div');
        requestHeader.className = 'right-section-header';
        requestHeader.textContent = 'Request samples';
        requestSection.appendChild(requestHeader);
        requestSection.appendChild(renderCodeExampleStreams(ep));
        container.appendChild(requestSection);
      } else {
        // For other protocols, just show basic code example
        container.appendChild(renderCodeExample(ep));
      }

      return container;
    }

    // WebSocket code examples (wscat, etc.)
    function renderCodeExampleWebSocket(ep) {
      const container = document.createElement('div');
      container.className = 'code-example';

      const baseUrl = (spec.servers && spec.servers[0]?.url) || 'http://localhost:3000';
      const wsUrl = baseUrl.replace(/^http/, 'ws') + (ep.path || '/' + ep.id);

      // Language tabs
      const languages = ['wscat', 'javascript', 'python'];
      const tabs = document.createElement('div');
      tabs.className = 'code-tabs';

      const contents = document.createElement('div');
      contents.className = 'code-contents';

      languages.forEach((lang, i) => {
        // Tab button
        const tab = document.createElement('button');
        tab.className = 'code-tab' + (i === 0 ? ' active' : '');
        tab.textContent = lang === 'wscat' ? 'wscat' : lang === 'javascript' ? 'JavaScript' : 'Python';
        tab.onclick = () => {
          tabs.querySelectorAll('.code-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          contents.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));
          contents.querySelector('.code-content[data-lang="' + lang + '"]').classList.add('active');
        };
        tabs.appendChild(tab);

        // Content
        const content = document.createElement('div');
        content.className = 'code-content' + (i === 0 ? ' active' : '');
        content.setAttribute('data-lang', lang);

        const pre = document.createElement('pre');
        const code = document.createElement('code');
        code.textContent = generateWsCodeSample(lang, wsUrl, ep);
        pre.appendChild(code);
        content.appendChild(pre);
        contents.appendChild(content);
      });

      container.appendChild(tabs);
      container.appendChild(contents);

      return container;
    }

    function generateWsCodeSample(lang, url, ep) {
      const data = ep.data || {};
      let exampleMsg = {};
      if (data.subscribe?.message?.payload) {
        exampleMsg = buildExampleFromSchema(data.subscribe.message.payload);
      } else if (data.publish?.message?.payload) {
        exampleMsg = buildExampleFromSchema(data.publish.message.payload);
      }
      const msgStr = JSON.stringify(exampleMsg || {}, null, 2);

      switch (lang) {
        case 'wscat':
          return 'wscat -c "' + url + '"\\n\\n# Once connected, send messages:\\n> ' + msgStr.replace(/\\n/g, '');

        case 'javascript':
          return 'const ws = new WebSocket("' + url + '");\\n\\n' +
            'ws.onopen = () => {\\n' +
            '  console.log("Connected");\\n' +
            '  ws.send(JSON.stringify(' + msgStr.split('\\n').map((l, i) => i === 0 ? l : '    ' + l).join('\\n') + '));\\n' +
            '};\\n\\n' +
            'ws.onmessage = (event) => {\\n' +
            '  console.log("Received:", event.data);\\n' +
            '};\\n\\n' +
            'ws.onclose = () => {\\n' +
            '  console.log("Disconnected");\\n' +
            '};';

        case 'python':
          return 'import asyncio\\n' +
            'import websockets\\n\\n' +
            'async def connect():\\n' +
            '    async with websockets.connect("' + url + '") as ws:\\n' +
            '        await ws.send(\\'\\'\\'\\n' + msgStr + '\\n\\'\\'\\')\\n' +
            '        response = await ws.recv()\\n' +
            '        print(f"Received: {response}")\\n\\n' +
            'asyncio.run(connect())';

        default:
          return '// Not implemented';
      }
    }

    // Streams (SSE) code examples
    function renderCodeExampleStreams(ep) {
      const container = document.createElement('div');
      container.className = 'code-example';

      const baseUrl = (spec.servers && spec.servers[0]?.url) || 'http://localhost:3000';
      const streamUrl = baseUrl + (ep.path || '/' + ep.id);

      // Language tabs
      const languages = ['curl', 'javascript', 'python'];
      const tabs = document.createElement('div');
      tabs.className = 'code-tabs';

      const contents = document.createElement('div');
      contents.className = 'code-contents';

      languages.forEach((lang, i) => {
        // Tab button
        const tab = document.createElement('button');
        tab.className = 'code-tab' + (i === 0 ? ' active' : '');
        tab.textContent = lang === 'curl' ? 'cURL' : lang === 'javascript' ? 'JavaScript' : 'Python';
        tab.onclick = () => {
          tabs.querySelectorAll('.code-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          contents.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));
          contents.querySelector('.code-content[data-lang="' + lang + '"]').classList.add('active');
        };
        tabs.appendChild(tab);

        // Content
        const content = document.createElement('div');
        content.className = 'code-content' + (i === 0 ? ' active' : '');
        content.setAttribute('data-lang', lang);

        const pre = document.createElement('pre');
        const code = document.createElement('code');
        code.textContent = generateStreamCodeSample(lang, streamUrl, ep);
        pre.appendChild(code);
        content.appendChild(pre);
        contents.appendChild(content);
      });

      container.appendChild(tabs);
      container.appendChild(contents);

      return container;
    }

    function generateStreamCodeSample(lang, url, ep) {
      switch (lang) {
        case 'curl':
          return 'curl -N "' + url + '"\\n\\n# -N disables buffering for streaming output';

        case 'javascript':
          return 'const eventSource = new EventSource("' + url + '");\\n\\n' +
            'eventSource.onmessage = (event) => {\\n' +
            '  console.log("Received:", event.data);\\n' +
            '};\\n\\n' +
            'eventSource.onerror = (error) => {\\n' +
            '  console.error("Error:", error);\\n' +
            '  eventSource.close();\\n' +
            '};\\n\\n' +
            '// To close the connection:\\n' +
            '// eventSource.close();';

        case 'python':
          return 'import sseclient\\n' +
            'import requests\\n\\n' +
            'response = requests.get("' + url + '", stream=True)\\n' +
            'client = sseclient.SSEClient(response)\\n\\n' +
            'for event in client.events():\\n' +
            '    print(f"Event: {event.event}, Data: {event.data}")';

        default:
          return '// Not implemented';
      }
    }

    // JSON syntax highlighting
    function syntaxHighlightJSON(json) {
      return json
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/("(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\"])*"(\\s*:)?)/g, function(match) {
          let cls = 'json-string';
          if (/:$/.test(match)) {
            cls = 'json-key';
            match = match.replace(/:$/, '') + ':';
          }
          return '<span class="' + cls + '">' + match + '</span>';
        })
        .replace(/\\b(true|false|null)\\b/g, '<span class="json-boolean">$1</span>')
        .replace(/\\b(-?\\d+\\.?\\d*)\\b/g, '<span class="json-number">$1</span>');
    }

    function renderCodeExample(ep) {
      const container = document.createElement('div');
      container.className = 'code-example';

      // Build request details
      const method = ep.method.toUpperCase();
      const path = ep.path;
      const baseUrl = (spec.servers && spec.servers[0]?.url) || 'http://localhost:3000';
      const fullUrl = baseUrl + path;

      // Get request body if exists
      let exampleBody = null;
      const opData = ep.data;
      if (opData && opData.requestBody && opData.requestBody.content) {
        const jsonContent = opData.requestBody.content['application/json'];
        if (jsonContent && jsonContent.schema) {
          exampleBody = buildExampleFromSchema(jsonContent.schema);
        }
      }

      // Language tabs
      const languages = ['curl', 'typescript', 'python', 'go'];
      const tabs = document.createElement('div');
      tabs.className = 'code-tabs';

      const contents = document.createElement('div');
      contents.className = 'code-contents';

      languages.forEach((lang, i) => {
        // Tab button
        const tab = document.createElement('button');
        tab.className = 'code-tab' + (i === 0 ? ' active' : '');
        tab.textContent = lang === 'typescript' ? 'TypeScript' : lang === 'curl' ? 'cURL' : lang.charAt(0).toUpperCase() + lang.slice(1);
        tab.onclick = () => {
          tabs.querySelectorAll('.code-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          contents.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));
          contents.querySelector('.code-content[data-lang="' + lang + '"]').classList.add('active');
        };
        tabs.appendChild(tab);

        // Content
        const content = document.createElement('div');
        content.className = 'code-content' + (i === 0 ? ' active' : '');
        content.setAttribute('data-lang', lang);

        const pre = document.createElement('pre');
        const code = document.createElement('code');
        code.textContent = generateCodeSample(lang, method, fullUrl, exampleBody);
        pre.appendChild(code);
        content.appendChild(pre);
        contents.appendChild(content);
      });

      container.appendChild(tabs);
      container.appendChild(contents);

      return container;
    }

    function generateCodeSample(lang, method, url, body) {
      const hasBody = body && ['POST', 'PUT', 'PATCH'].includes(method);
      const bodyStr = body ? JSON.stringify(body, null, 2) : '';

      switch (lang) {
        case 'curl':
          const curlLines = [];
          curlLines.push('curl' + (method !== 'GET' ? ' -X ' + method : ''));
          curlLines.push('  "' + url + '"');
          if (hasBody) {
            curlLines.push('  -H "Content-Type: application/json"');
            curlLines.push("  -d '" + bodyStr + "'");
          }
          return curlLines.join(' \\\\\\n');

        case 'typescript':
          if (hasBody) {
            return 'const response = await fetch("' + url + '", {\\n' +
              '  method: "' + method + '",\\n' +
              '  headers: {\\n' +
              '    "Content-Type": "application/json",\\n' +
              '  },\\n' +
              '  body: JSON.stringify(' + bodyStr.split('\\n').map((l, i) => i === 0 ? l : '    ' + l).join('\\n') + '),\\n' +
              '});\\n\\n' +
              'const data = await response.json();\\n' +
              'console.log(data);';
          }
          return 'const response = await fetch("' + url + '"' +
            (method !== 'GET' ? ', {\\n  method: "' + method + '",\\n}' : '') + ');\\n\\n' +
            'const data = await response.json();\\n' +
            'console.log(data);';

        case 'python':
          if (hasBody) {
            return 'import requests\\n\\n' +
              'response = requests.' + method.toLowerCase() + '(\\n' +
              '    "' + url + '",\\n' +
              '    json=' + bodyStr.split('\\n').map((l, i) => i === 0 ? l : '    ' + l).join('\\n') + ',\\n' +
              ')\\n\\n' +
              'print(response.json())';
          }
          return 'import requests\\n\\n' +
            'response = requests.' + method.toLowerCase() + '("' + url + '")\\n\\n' +
            'print(response.json())';

        case 'go':
          if (hasBody) {
            return 'package main\\n\\n' +
              'import (\\n' +
              '    "bytes"\\n' +
              '    "encoding/json"\\n' +
              '    "fmt"\\n' +
              '    "net/http"\\n' +
              '    "io"\\n' +
              ')\\n\\n' +
              'func main() {\\n' +
              '    body, _ := json.Marshal(map[string]interface{}{\\n' +
              generateGoMapBody(body) +
              '    })\\n\\n' +
              '    req, _ := http.NewRequest("' + method + '", "' + url + '", bytes.NewBuffer(body))\\n' +
              '    req.Header.Set("Content-Type", "application/json")\\n\\n' +
              '    client := &http.Client{}\\n' +
              '    resp, _ := client.Do(req)\\n' +
              '    defer resp.Body.Close()\\n\\n' +
              '    data, _ := io.ReadAll(resp.Body)\\n' +
              '    fmt.Println(string(data))\\n' +
              '}';
          }
          return 'package main\\n\\n' +
            'import (\\n' +
            '    "fmt"\\n' +
            '    "net/http"\\n' +
            '    "io"\\n' +
            ')\\n\\n' +
            'func main() {\\n' +
            '    resp, _ := http.Get("' + url + '")\\n' +
            '    defer resp.Body.Close()\\n\\n' +
            '    body, _ := io.ReadAll(resp.Body)\\n' +
            '    fmt.Println(string(body))\\n' +
            '}';

        default:
          return '// Not implemented';
      }
    }

    function generateGoMapBody(body) {
      if (!body || typeof body !== 'object') return '';
      const lines = [];
      for (const [key, value] of Object.entries(body)) {
        const goValue = typeof value === 'string' ? '"' + value + '"' :
                       typeof value === 'number' ? String(value) :
                       typeof value === 'boolean' ? String(value) :
                       'nil';
        lines.push('        "' + key + '": ' + goValue + ',');
      }
      return lines.join('\\n') + '\\n';
    }

    function buildExampleFromSchema(schema) {
      if (!schema) return null;

      // Resolve $ref
      if (schema.$ref) {
        const resolved = resolveRef(schema.$ref);
        return buildExampleFromSchema(resolved);
      }

      // Normalize non-standard format
      schema = normalizeSchema(schema);

      if (schema.example !== undefined) return schema.example;
      if (schema.default !== undefined) return schema.default;

      if (schema.type === 'object' && schema.properties) {
        const obj = {};
        for (const [key, prop] of Object.entries(schema.properties)) {
          obj[key] = buildExampleFromSchema(prop);
        }
        return obj;
      }

      if (schema.type === 'array' && schema.items) {
        return [buildExampleFromSchema(schema.items)];
      }

      // Primitive defaults
      switch (schema.type) {
        case 'string': return schema.format === 'email' ? 'user@example.com' : 'string';
        case 'number': return 0;
        case 'integer': return 0;
        case 'boolean': return true;
        default: return null;
      }
    }

    // ========== SCHEMA RENDERING HELPERS ==========

    function resolveRef(ref) {
      if (!ref || typeof ref !== 'string') return null;
      const parts = ref.replace('#/', '').split('/');
      let result = spec;
      for (const part of parts) {
        if (!result) return null;
        result = result[part];
      }
      return result;
    }

    function getSchemaType(schema) {
      if (!schema) return 'any';
      if (schema.$ref) {
        const resolved = resolveRef(schema.$ref);
        return resolved ? getSchemaType(resolved) : 'ref';
      }
      if (schema.oneOf) return 'oneOf';
      if (schema.anyOf) return 'anyOf';
      if (schema.allOf) return 'allOf';
      if (Array.isArray(schema.type)) return schema.type.join(' | ');
      return schema.type || 'any';
    }

    function getTypeClass(type) {
      const t = (type || '').toLowerCase();
      if (t === 'string') return 'type-string';
      if (t === 'number' || t === 'integer') return 'type-number';
      if (t === 'boolean') return 'type-boolean';
      if (t === 'object') return 'type-object';
      if (t === 'array') return 'type-array';
      if (t === 'null') return 'type-null';
      return 'type-ref';
    }

    function getRefName(ref) {
      if (!ref) return '';
      const parts = ref.split('/');
      return parts[parts.length - 1];
    }

    function renderSchemaType(schema, showFormat) {
      if (!schema) return '<span class="schema-type type-ref">any</span>';

      if (schema.$ref) {
        const name = getRefName(schema.$ref);
        return '<span class="schema-type type-ref">' + esc(name) + '</span>';
      }

      let type = getSchemaType(schema);
      let extra = '';

      if (schema.format && showFormat !== false) {
        extra = '<' + schema.format + '>';
      }

      if (type === 'array' && schema.items) {
        const itemType = schema.items.$ref
          ? getRefName(schema.items.$ref)
          : getSchemaType(schema.items);
        return '<span class="schema-type type-array">array[' + esc(itemType) + ']</span>';
      }

      if (type === 'oneOf' || type === 'anyOf' || type === 'allOf') {
        const items = schema[type];
        const types = items.map(s => s.$ref ? getRefName(s.$ref) : getSchemaType(s));
        return '<span class="schema-type type-ref">' + esc(type) + '(' + types.join(', ') + ')</span>';
      }

      return '<span class="schema-type ' + getTypeClass(type) + '">' + esc(type + extra) + '</span>';
    }

    function renderConstraints(schema) {
      const constraints = [];

      // String constraints
      if (schema.minLength !== undefined) constraints.push('minLength: ' + schema.minLength);
      if (schema.maxLength !== undefined) constraints.push('maxLength: ' + schema.maxLength);
      if (schema.pattern) constraints.push('pattern: ' + schema.pattern);

      // Number constraints
      if (schema.minimum !== undefined) constraints.push('min: ' + schema.minimum);
      if (schema.maximum !== undefined) constraints.push('max: ' + schema.maximum);
      if (schema.exclusiveMinimum !== undefined) constraints.push('exclusiveMin: ' + schema.exclusiveMinimum);
      if (schema.exclusiveMaximum !== undefined) constraints.push('exclusiveMax: ' + schema.exclusiveMaximum);
      if (schema.multipleOf !== undefined) constraints.push('multipleOf: ' + schema.multipleOf);

      // Array constraints
      if (schema.minItems !== undefined) constraints.push('minItems: ' + schema.minItems);
      if (schema.maxItems !== undefined) constraints.push('maxItems: ' + schema.maxItems);
      if (schema.uniqueItems) constraints.push('uniqueItems');

      // Object constraints
      if (schema.minProperties !== undefined) constraints.push('minProperties: ' + schema.minProperties);
      if (schema.maxProperties !== undefined) constraints.push('maxProperties: ' + schema.maxProperties);

      if (constraints.length === 0) return '';

      return '<div class="schema-constraints">' +
        constraints.map(c => '<span class="schema-constraint">' + esc(c) + '</span>').join('') +
        '</div>';
    }

    function renderEnumValues(schema) {
      if (!schema.enum || schema.enum.length === 0) return '';

      return '<div class="schema-enum">' +
        '<span style="font-size: 11px; color: var(--text-muted); margin-right: 4px;">Enum:</span>' +
        schema.enum.map(v => '<span class="schema-enum-value">' + esc(JSON.stringify(v)) + '</span>').join('') +
        '</div>';
    }

    function renderDefault(schema) {
      if (schema.default === undefined) return '';
      return '<div class="schema-default">Default: <code>' + esc(JSON.stringify(schema.default)) + '</code></div>';
    }

    let schemaIdCounter = 0;

    // Normalize non-standard schema formats (e.g., from some Zod conversions)
    function normalizeSchema(schema) {
      if (!schema) return schema;

      // Handle schemas with 'def' and 'shape' (non-standard Zod output)
      if (schema.def && schema.def.shape) {
        const normalized = { type: 'object', properties: {} };
        for (const [key, val] of Object.entries(schema.def.shape)) {
          normalized.properties[key] = normalizeSchema(val);
        }
        return normalized;
      }

      // Handle 'innerType' for default values
      if (schema.def && schema.def.innerType) {
        const inner = normalizeSchema(schema.def.innerType);
        if (schema.def.defaultValue !== undefined) {
          inner.default = schema.def.defaultValue;
        }
        return inner;
      }

      // Handle simple def types
      if (schema.def && schema.def.type === 'string') {
        const result = { type: 'string' };
        if (schema.format) result.format = schema.format;
        if (schema.minLength) result.minLength = schema.minLength;
        if (schema.maxLength) result.maxLength = schema.maxLength;
        return result;
      }

      if (schema.def && schema.def.type === 'number') {
        return { type: 'number' };
      }

      if (schema.def && schema.def.type === 'integer') {
        return { type: 'integer' };
      }

      if (schema.def && schema.def.type === 'boolean') {
        return { type: 'boolean' };
      }

      return schema;
    }

    // ========== REDOC-STYLE RENDERING FUNCTIONS ==========

    function renderParametersRedocStyle(params) {
      const container = document.createElement('div');

      params.forEach(param => {
        const row = document.createElement('div');
        row.className = 'param-row';

        // Tree line
        const tree = document.createElement('div');
        tree.className = 'param-tree';
        tree.innerHTML = '<div class="param-tree-line"></div>';
        row.appendChild(tree);

        // Info
        const info = document.createElement('div');
        info.className = 'param-info';

        // Header row: name, required badge, type
        const header = document.createElement('div');
        header.className = 'param-header';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'param-name-text';
        nameSpan.textContent = param.name;
        header.appendChild(nameSpan);

        if (param.required) {
          const reqBadge = document.createElement('span');
          reqBadge.className = 'param-required-badge';
          reqBadge.textContent = 'required';
          header.appendChild(reqBadge);
        }

        // Type info
        const schema = param.schema || {};
        const typeInfo = document.createElement('span');
        typeInfo.className = 'param-type-info';
        let typeText = schema.type || 'string';
        if (schema.format) {
          typeText += ' <span class="format">&lt;' + esc(schema.format) + '&gt;</span>';
        }
        typeInfo.innerHTML = typeText;
        header.appendChild(typeInfo);

        // Constraints
        if (schema.maximum !== undefined || schema.minimum !== undefined) {
          const constraint = document.createElement('span');
          constraint.className = 'param-constraint';
          if (schema.maximum !== undefined) {
            constraint.textContent = '<= ' + schema.maximum;
          } else if (schema.minimum !== undefined) {
            constraint.textContent = '>= ' + schema.minimum;
          }
          header.appendChild(constraint);
        }

        info.appendChild(header);

        // Default value
        if (schema.default !== undefined) {
          const def = document.createElement('div');
          def.className = 'param-default';
          def.innerHTML = 'Default: <code>' + esc(JSON.stringify(schema.default)) + '</code>';
          info.appendChild(def);
        }

        // Example
        if (schema.example !== undefined || param.example !== undefined) {
          const ex = document.createElement('div');
          ex.className = 'param-example';
          const exValue = param.example !== undefined ? param.example : schema.example;
          ex.innerHTML = 'Example: <code>' + esc(param.name + '=' + exValue) + '</code>';
          info.appendChild(ex);
        }

        // Description
        if (param.description || schema.description) {
          const desc = document.createElement('div');
          desc.className = 'param-description';
          desc.textContent = param.description || schema.description;
          info.appendChild(desc);
        }

        row.appendChild(info);
        container.appendChild(row);
      });

      return container;
    }

    function renderRequestBodyRedocStyle(reqBody) {
      const container = document.createElement('div');

      // Get schema
      const content = reqBody.content || {};
      const contentType = Object.keys(content)[0] || 'application/json';
      const mediaType = content[contentType] || {};
      const schema = mediaType.schema;

      if (schema) {
        // Resolve and normalize
        let actualSchema = schema.$ref ? resolveRef(schema.$ref) : schema;
        actualSchema = normalizeSchema(actualSchema);

        // Render properties as Redoc-style rows
        if (actualSchema && actualSchema.properties) {
          const required = actualSchema.required || [];
          Object.entries(actualSchema.properties).forEach(([propName, propSchema]) => {
            const row = renderPropertyRow(propName, propSchema, required.includes(propName), 0);
            container.appendChild(row);
          });
        } else if (actualSchema && actualSchema.type === 'array' && actualSchema.items) {
          const itemSchema = actualSchema.items.$ref ? resolveRef(actualSchema.items.$ref) : actualSchema.items;
          const arrayLabel = document.createElement('div');
          arrayLabel.style.marginBottom = '12px';
          arrayLabel.innerHTML = '<span class="param-type-info">Array [</span>';
          container.appendChild(arrayLabel);

          if (itemSchema && itemSchema.properties) {
            const required = itemSchema.required || [];
            Object.entries(itemSchema.properties).forEach(([propName, propSchema]) => {
              const row = renderPropertyRow(propName, propSchema, required.includes(propName), 1);
              container.appendChild(row);
            });
          }

          const arrayEnd = document.createElement('div');
          arrayEnd.innerHTML = '<span class="param-type-info">]</span>';
          container.appendChild(arrayEnd);
        }
      }

      return container;
    }

    function renderPropertyRow(name, schema, isRequired, depth) {
      const row = document.createElement('div');
      row.className = 'param-row';
      if (depth > 0) {
        row.style.paddingLeft = (depth * 20) + 'px';
      }

      // Tree line
      const tree = document.createElement('div');
      tree.className = 'param-tree';
      tree.innerHTML = '<div class="param-tree-line"></div>';
      row.appendChild(tree);

      // Info
      const info = document.createElement('div');
      info.className = 'param-info';

      // Header row
      const header = document.createElement('div');
      header.className = 'param-header';

      const nameSpan = document.createElement('span');
      nameSpan.className = 'param-name-text';
      nameSpan.textContent = name;
      header.appendChild(nameSpan);

      if (isRequired) {
        const reqBadge = document.createElement('span');
        reqBadge.className = 'param-required-badge';
        reqBadge.textContent = 'required';
        header.appendChild(reqBadge);
      }

      // Type info
      const resolved = schema.$ref ? resolveRef(schema.$ref) : schema;
      const normalized = normalizeSchema(resolved) || resolved || {};
      const typeInfo = document.createElement('span');
      typeInfo.className = 'param-type-info';
      let typeText = normalized.type || 'any';
      if (normalized.format) {
        typeText += ' <span class="format">(' + esc(normalized.format) + ')</span>';
      }
      if (schema.$ref) {
        typeText = '<span class="format">' + esc(getRefName(schema.$ref)) + '</span>';
      }
      typeInfo.innerHTML = typeText;
      header.appendChild(typeInfo);

      // Pattern/constraint
      if (normalized.pattern) {
        const constraint = document.createElement('span');
        constraint.className = 'param-constraint';
        constraint.textContent = normalized.pattern;
        header.appendChild(constraint);
      }

      info.appendChild(header);

      // Default
      if (normalized.default !== undefined) {
        const def = document.createElement('div');
        def.className = 'param-default';
        def.innerHTML = 'Default: <code>' + esc(JSON.stringify(normalized.default)) + '</code>';
        info.appendChild(def);
      }

      // Example
      if (normalized.example !== undefined) {
        const ex = document.createElement('div');
        ex.className = 'param-example';
        ex.innerHTML = 'Example: <code>' + esc(JSON.stringify(normalized.example)) + '</code>';
        info.appendChild(ex);
      }

      // Description
      if (normalized.description) {
        const desc = document.createElement('div');
        desc.className = 'param-description';
        desc.textContent = normalized.description;
        info.appendChild(desc);
      }

      row.appendChild(info);
      return row;
    }

    function renderResponsesRedocStyle(responses) {
      const container = document.createElement('div');
      const statusCodes = Object.keys(responses).sort();

      statusCodes.forEach((status, idx) => {
        const response = responses[status];
        const statusClass = status.startsWith('2') ? 'status-2xx' :
                           status.startsWith('4') ? 'status-4xx' :
                           status.startsWith('5') ? 'status-5xx' : '';

        const item = document.createElement('div');
        item.className = 'response-item' + (idx === 0 ? ' expanded' : '');

        // Header
        const header = document.createElement('div');
        header.className = 'response-header';
        header.innerHTML = '<span class="response-arrow">â–¶</span>' +
          '<span class="response-status ' + statusClass + '">' + esc(status) + '</span>' +
          '<span class="response-desc">' + esc(response.description || '') + '</span>';
        header.onclick = () => item.classList.toggle('expanded');
        item.appendChild(header);

        // Body (headers + schema)
        const body = document.createElement('div');
        body.className = 'response-body';

        // Render response headers if present
        if (response.headers && Object.keys(response.headers).length > 0) {
          const headersSection = document.createElement('div');
          headersSection.className = 'response-headers-section';

          const headersLabel = document.createElement('div');
          headersLabel.className = 'response-headers-label';
          headersLabel.textContent = 'RESPONSE HEADERS';
          headersSection.appendChild(headersLabel);

          Object.entries(response.headers).forEach(([headerName, headerDef]) => {
            const resolved = headerDef.$ref ? resolveRef(headerDef.$ref) : headerDef;
            const row = document.createElement('div');
            row.className = 'response-header-row';

            const nameEl = document.createElement('div');
            nameEl.className = 'response-header-name';
            nameEl.textContent = headerName;
            if (resolved.required) {
              nameEl.innerHTML += '<span class="response-header-required">required</span>';
            }

            const infoEl = document.createElement('div');
            infoEl.className = 'response-header-info';

            const typeStr = resolved.schema ? (resolved.schema.type || 'string') : 'string';
            const typeEl = document.createElement('div');
            typeEl.className = 'response-header-type';
            typeEl.textContent = typeStr;
            infoEl.appendChild(typeEl);

            if (resolved.description) {
              const descEl = document.createElement('div');
              descEl.className = 'response-header-desc';
              descEl.textContent = resolved.description;
              infoEl.appendChild(descEl);
            }

            row.appendChild(nameEl);
            row.appendChild(infoEl);
            headersSection.appendChild(row);
          });

          body.appendChild(headersSection);
        }

        const respContent = response.content || {};
        const contentType = Object.keys(respContent)[0];
        if (contentType) {
          const label = document.createElement('div');
          label.className = 'response-schema-label';
          label.innerHTML = 'RESPONSE SCHEMA: <span class="content-type">' + esc(contentType) + '</span>';
          body.appendChild(label);

          const mediaType = respContent[contentType] || {};
          const schema = mediaType.schema;
          if (schema) {
            let actualSchema = schema.$ref ? resolveRef(schema.$ref) : schema;
            actualSchema = normalizeSchema(actualSchema);

            if (actualSchema && actualSchema.properties) {
              const required = actualSchema.required || [];
              Object.entries(actualSchema.properties).forEach(([propName, propSchema]) => {
                const row = renderPropertyRow(propName, propSchema, required.includes(propName), 0);
                body.appendChild(row);
              });
            } else if (actualSchema && actualSchema.type === 'array' && actualSchema.items) {
              const itemSchema = actualSchema.items.$ref ? resolveRef(actualSchema.items.$ref) : actualSchema.items;
              const arrayLabel = document.createElement('div');
              arrayLabel.innerHTML = '<span class="param-type-info">Array [</span>';
              arrayLabel.style.marginBottom = '8px';
              body.appendChild(arrayLabel);

              if (itemSchema && itemSchema.properties) {
                const itemRequired = itemSchema.required || [];
                Object.entries(itemSchema.properties).forEach(([propName, propSchema]) => {
                  const row = renderPropertyRow(propName, propSchema, itemRequired.includes(propName), 1);
                  body.appendChild(row);
                });
              }

              const arrayEnd = document.createElement('div');
              arrayEnd.innerHTML = '<span class="param-type-info">]</span>';
              body.appendChild(arrayEnd);
            }
          }
        }

        item.appendChild(body);
        container.appendChild(item);
      });

      return container;
    }

    function renderSchemaProperties(schema, requiredProps, depth) {
      const container = document.createElement('div');
      container.className = 'schema-container';

      // Normalize non-standard schemas first
      let actualSchema = normalizeSchema(schema);

      // Handle $ref
      if (actualSchema.$ref) {
        const resolved = resolveRef(actualSchema.$ref);
        actualSchema = normalizeSchema(resolved) || actualSchema;
      }

      // Handle allOf, oneOf, anyOf by merging/showing options
      if (actualSchema.allOf) {
        actualSchema.allOf.forEach((subSchema, idx) => {
          const resolved = subSchema.$ref ? resolveRef(subSchema.$ref) : subSchema;
          if (resolved && resolved.properties) {
            renderPropertiesInto(container, resolved, resolved.required || [], depth);
          }
        });
        return container;
      }

      if (actualSchema.oneOf || actualSchema.anyOf) {
        const variants = actualSchema.oneOf || actualSchema.anyOf;
        const label = actualSchema.oneOf ? 'One of' : 'Any of';
        const row = document.createElement('div');
        row.className = 'schema-row';
        row.innerHTML = '<div class="schema-property">' +
          '<span class="schema-name" style="font-style: italic;">' + label + ':</span>' +
          '</div><div class="schema-details">' +
          variants.map((v, i) => {
            const name = v.$ref ? getRefName(v.$ref) : ('Option ' + (i + 1));
            return '<span class="schema-type type-ref" style="margin-right: 6px; cursor: pointer;">' + esc(name) + '</span>';
          }).join('') +
          '</div>';
        container.appendChild(row);
        return container;
      }

      // Render object properties
      if (actualSchema.properties) {
        renderPropertiesInto(container, actualSchema, requiredProps || actualSchema.required || [], depth);
      } else if (actualSchema.type === 'array' && actualSchema.items) {
        // For arrays, show the items schema
        const itemSchema = actualSchema.items.$ref ? resolveRef(actualSchema.items.$ref) : actualSchema.items;
        if (itemSchema && itemSchema.properties) {
          renderPropertiesInto(container, itemSchema, itemSchema.required || [], depth);
        } else {
          const row = document.createElement('div');
          row.className = 'schema-row';
          row.innerHTML = '<div class="schema-property">' +
            '<span class="schema-name">[items]</span>' +
            '</div><div class="schema-details">' +
            renderSchemaType(actualSchema.items, true) +
            '</div>';
          container.appendChild(row);
        }
      } else if (Object.keys(actualSchema).length === 0 || actualSchema.type === 'object') {
        const row = document.createElement('div');
        row.className = 'schema-row';
        row.innerHTML = '<div class="schema-property">' +
          '<span class="schema-name" style="color: var(--text-muted); font-style: italic;">empty object</span>' +
          '</div>';
        container.appendChild(row);
      }

      return container;
    }

    function renderPropertiesInto(container, schema, requiredProps, depth) {
      const props = schema.properties || {};
      const required = requiredProps || [];
      const depthClass = depth > 0 ? ' nested' + (depth > 1 ? '-' + Math.min(depth, 4) : '') : '';

      Object.entries(props).forEach(([propName, propSchema]) => {
        const isRequired = required.includes(propName);
        const resolved = propSchema.$ref ? resolveRef(propSchema.$ref) : propSchema;
        const hasNested = resolved && (resolved.properties || (resolved.type === 'array' && resolved.items?.properties));

        const row = document.createElement('div');
        row.className = 'schema-row' + depthClass;

        const id = 'schema-' + (schemaIdCounter++);

        let toggleHtml = '';
        if (hasNested) {
          toggleHtml = '<span class="schema-toggle" data-target="' + id + '">â–¼ expand</span>';
        }

        let detailsHtml = '<div class="schema-details">' +
          renderSchemaType(propSchema, true) + toggleHtml;

        if (resolved?.description) {
          detailsHtml += '<div class="schema-desc">' + esc(resolved.description) + '</div>';
        }

        detailsHtml += renderConstraints(resolved || {});
        detailsHtml += renderEnumValues(resolved || {});
        detailsHtml += renderDefault(resolved || {});
        detailsHtml += '</div>';

        row.innerHTML = '<div class="schema-property">' +
          '<span class="schema-name">' + esc(propName) + '</span>' +
          (isRequired ? '<span class="schema-required">*</span>' : '') +
          '</div>' + detailsHtml;

        container.appendChild(row);

        // Add nested container for expandable schemas
        if (hasNested) {
          const nestedContainer = document.createElement('div');
          nestedContainer.id = id;
          nestedContainer.className = 'schema-nested-container collapsed';

          if (resolved.properties) {
            const nested = renderSchemaProperties(resolved, resolved.required || [], depth + 1);
            nestedContainer.appendChild(nested);
          } else if (resolved.type === 'array' && resolved.items) {
            const itemSchema = resolved.items.$ref ? resolveRef(resolved.items.$ref) : resolved.items;
            if (itemSchema) {
              const nested = renderSchemaProperties(itemSchema, itemSchema.required || [], depth + 1);
              nestedContainer.appendChild(nested);
            }
          }

          container.appendChild(nestedContainer);

          // Add click handler for toggle
          const toggle = row.querySelector('.schema-toggle');
          if (toggle) {
            toggle.onclick = () => {
              nestedContainer.classList.toggle('collapsed');
              toggle.textContent = nestedContainer.classList.contains('collapsed') ? 'â–¼ expand' : 'â–² collapse';
            };
          }
        }
      });
    }

    function renderParameters(params) {
      if (!params || params.length === 0) return null;

      const container = document.createElement('div');
      const table = document.createElement('table');
      table.className = 'params-table';

      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>Name</th><th>Type</th><th>Description</th></tr>';
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      params.forEach(param => {
        const schema = param.schema || {};
        const tr = document.createElement('tr');
        tr.innerHTML = '<td>' +
          '<span class="param-name">' + esc(param.name) + '</span>' +
          '<span class="param-in">' + esc(param.in) + '</span>' +
          (param.required ? '<span class="schema-required"> *</span>' : '') +
          '</td>' +
          '<td>' + renderSchemaType(schema, true) + '</td>' +
          '<td>' + esc(param.description || schema.description || '') +
          renderDefault(schema) + '</td>';
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      container.appendChild(table);

      return container;
    }

    function renderRequestBody(reqBody) {
      if (!reqBody) return null;

      const container = document.createElement('div');

      if (reqBody.description) {
        const desc = document.createElement('p');
        desc.className = 'schema-desc';
        desc.textContent = reqBody.description;
        container.appendChild(desc);
      }

      // Get content type (usually application/json)
      const content = reqBody.content || {};
      const contentType = Object.keys(content)[0] || 'application/json';
      const mediaType = content[contentType] || {};
      const schema = mediaType.schema;

      if (schema) {
        const schemaEl = renderSchemaProperties(schema, schema.required || [], 0);
        container.appendChild(schemaEl);

        // Show example if available
        if (mediaType.example || schema.example) {
          const example = mediaType.example || schema.example;
          const exampleDiv = document.createElement('div');
          exampleDiv.className = 'schema-example';
          exampleDiv.innerHTML = '<div class="schema-example-header">Example</div>' +
            '<div class="schema-example-body">' + esc(JSON.stringify(example, null, 2)) + '</div>';
          container.appendChild(exampleDiv);
        }
      }

      return container;
    }

    function renderResponses(responses) {
      if (!responses) return null;

      const container = document.createElement('div');
      const statusCodes = Object.keys(responses).sort();

      if (statusCodes.length === 0) return null;

      // Create tabs
      const tabs = document.createElement('div');
      tabs.className = 'response-tabs';

      const contents = document.createElement('div');

      statusCodes.forEach((status, idx) => {
        const statusClass = status.startsWith('2') ? 'status-2xx' :
                           status.startsWith('4') ? 'status-4xx' :
                           status.startsWith('5') ? 'status-5xx' : '';

        const tab = document.createElement('button');
        tab.className = 'response-tab ' + statusClass + (idx === 0 ? ' active' : '');
        tab.textContent = status;
        tab.dataset.status = status;
        tabs.appendChild(tab);

        const content = document.createElement('div');
        content.className = 'response-content' + (idx === 0 ? ' active' : '');
        content.dataset.status = status;

        const response = responses[status];
        if (response.description) {
          const desc = document.createElement('p');
          desc.className = 'schema-desc';
          desc.textContent = response.description;
          content.appendChild(desc);
        }

        // Get schema from content
        const respContent = response.content || {};
        const contentType = Object.keys(respContent)[0] || 'application/json';
        const mediaType = respContent[contentType] || {};
        const schema = mediaType.schema;

        if (schema) {
          const schemaEl = renderSchemaProperties(schema, schema.required || [], 0);
          content.appendChild(schemaEl);

          // Show example if available
          if (mediaType.example || schema.example) {
            const example = mediaType.example || schema.example;
            const exampleDiv = document.createElement('div');
            exampleDiv.className = 'schema-example';
            exampleDiv.innerHTML = '<div class="schema-example-header">Example</div>' +
              '<div class="schema-example-body">' + esc(JSON.stringify(example, null, 2)) + '</div>';
            content.appendChild(exampleDiv);
          }
        }

        contents.appendChild(content);
      });

      container.appendChild(tabs);
      container.appendChild(contents);

      // Tab click handler
      tabs.onclick = (e) => {
        if (e.target.classList.contains('response-tab')) {
          const status = e.target.dataset.status;
          tabs.querySelectorAll('.response-tab').forEach(t => t.classList.remove('active'));
          contents.querySelectorAll('.response-content').forEach(c => c.classList.remove('active'));
          e.target.classList.add('active');
          contents.querySelector('[data-status="' + status + '"]').classList.add('active');
        }
      };

      return container;
    }

    function resolveEffectiveContentTypes(operationTypes, protocolTypes) {
      const globalTypes = (xUsd && xUsd.contentTypes) ? xUsd.contentTypes : {};
      const defaultType =
        (operationTypes && operationTypes.default) ||
        (protocolTypes && protocolTypes.default) ||
        globalTypes.default ||
        'application/json';
      const supportedList =
        (operationTypes && operationTypes.supported) ||
        (protocolTypes && protocolTypes.supported) ||
        globalTypes.supported ||
        [];
      const supported = Array.isArray(supportedList) ? supportedList.slice() : [];
      if (defaultType && supported.indexOf(defaultType) === -1) {
        supported.unshift(defaultType);
      }
      return { default: defaultType, supported };
    }

    function appendContentTypes(container, label, contentTypes) {
      if (!contentTypes) return;
      const section = document.createElement('div');
      section.className = 'endpoint-subsection';
      section.innerHTML = '<div class="subsection-label">' + esc(label) + '</div>';
      const grid = document.createElement('div');
      grid.className = 'info-grid';
      const supportedText = (contentTypes.supported && contentTypes.supported.length > 0)
        ? contentTypes.supported.join(', ')
        : contentTypes.default;
      grid.innerHTML =
        '<div class="info-card"><div class="info-card-title">Default</div><div class="info-card-value">' +
        esc(contentTypes.default || 'application/json') + '</div></div>' +
        '<div class="info-card"><div class="info-card-title">Supported</div><div class="info-card-value">' +
        esc(supportedText || 'application/json') + '</div></div>';
      section.appendChild(grid);
      container.appendChild(section);
    }

    function renderEndpointDetails(ep) {
      const container = document.createElement('div');
      const data = ep.data;

      // HTTP-specific (Redoc-style layout)
      if (activeProtocol === 'http') {
        // AUTHORIZATIONS section
        if (data.security && data.security.length > 0) {
          const authSection = document.createElement('div');
          authSection.className = 'endpoint-subsection';
          authSection.innerHTML = '<div class="subsection-label">AUTHORIZATIONS:</div>';
          const authValue = document.createElement('span');
          authValue.className = 'auth-value';
          const authNames = data.security.flatMap(s => Object.keys(s));
          authValue.textContent = authNames.join(', ') || 'None';
          authSection.appendChild(authValue);
          container.appendChild(authSection);
        }

        // PATH PARAMETERS
        const pathParams = (data.parameters || []).filter(p => p.in === 'path');
        if (pathParams.length > 0) {
          const section = document.createElement('div');
          section.className = 'endpoint-subsection';
          section.innerHTML = '<div class="subsection-label">PATH PARAMETERS</div>';
          section.appendChild(renderParametersRedocStyle(pathParams));
          container.appendChild(section);
        }

        // QUERY PARAMETERS
        const queryParams = (data.parameters || []).filter(p => p.in === 'query');
        if (queryParams.length > 0) {
          const section = document.createElement('div');
          section.className = 'endpoint-subsection';
          section.innerHTML = '<div class="subsection-label">QUERY PARAMETERS</div>';
          section.appendChild(renderParametersRedocStyle(queryParams));
          container.appendChild(section);
        }

        // HEADER PARAMETERS
        const headerParams = (data.parameters || []).filter(p => p.in === 'header');
        if (headerParams.length > 0) {
          const section = document.createElement('div');
          section.className = 'endpoint-subsection';
          section.innerHTML = '<div class="subsection-label">HEADER PARAMETERS</div>';
          section.appendChild(renderParametersRedocStyle(headerParams));
          container.appendChild(section);
        }

        // REQUEST BODY SCHEMA
        if (data.requestBody) {
          const section = document.createElement('div');
          section.className = 'endpoint-subsection';
          const contentType = Object.keys(data.requestBody.content || {})[0] || 'application/json';
          section.innerHTML = '<div class="subsection-label">REQUEST BODY SCHEMA: <span class="content-type">' + esc(contentType) + '</span></div>';
          const bodyEl = renderRequestBodyRedocStyle(data.requestBody);
          if (bodyEl) section.appendChild(bodyEl);
          container.appendChild(section);
        }

        // RESPONSES
        if (data.responses) {
          const section = document.createElement('div');
          section.className = 'endpoint-subsection';
          section.innerHTML = '<div class="subsection-label">Responses</div>';
          section.appendChild(renderResponsesRedocStyle(data.responses));
          container.appendChild(section);
        }
      }

      // WebSocket-specific
      if (activeProtocol === 'websocket') {
        if (data.type) {
          const badge = document.createElement('span');
          badge.className = 'badge channel-type-' + data.type;
          badge.textContent = data.type;
          badge.style.marginBottom = '16px';
          badge.style.display = 'inline-block';
          container.appendChild(badge);
        }
        if (data.subscribe) {
          appendContentTypes(
            container,
            'Subscribe Content Types',
            resolveEffectiveContentTypes(data.subscribe?.contentTypes, wsSpec?.contentTypes)
          );
        }
        if (data.publish) {
          appendContentTypes(
            container,
            'Publish Content Types',
            resolveEffectiveContentTypes(data.publish?.contentTypes, wsSpec?.contentTypes)
          );
        }
        if (data.parameters) {
          const paramSchema = { type: 'object', properties: {}, required: [] };
          Object.entries(data.parameters).forEach(([name, param]) => {
            const schema = param.schema || { type: 'string' };
            if (param.description) schema.description = param.description;
            paramSchema.properties[name] = schema;
            if (param.required) paramSchema.required.push(name);
          });
          const h = document.createElement('h4');
          h.textContent = 'Parameters';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(paramSchema, paramSchema.required, 0);
          container.appendChild(schemaEl);
        }
        const subscribePayload = resolveMessagePayload(data.subscribe?.message);
        if (subscribePayload) {
          const h = document.createElement('h4');
          h.textContent = 'Subscribe (receive)';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(subscribePayload, [], 0);
          container.appendChild(schemaEl);
        }
        const publishPayload = resolveMessagePayload(data.publish?.message);
        if (publishPayload) {
          const h = document.createElement('h4');
          h.textContent = 'Publish (send)';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(publishPayload, [], 0);
          container.appendChild(schemaEl);
        }
      }

      // Streams-specific
      if (activeProtocol === 'streams') {
        if (data.direction) {
          const badge = document.createElement('span');
          badge.className = 'badge badge-stream';
          badge.textContent = data.direction;
          badge.style.marginBottom = '16px';
          badge.style.display = 'inline-block';
          container.appendChild(badge);
        }
        appendContentTypes(
          container,
          'Content Types',
          resolveEffectiveContentTypes(data.contentTypes, streamsSpec?.contentTypes)
        );
        const streamPayload = resolveMessagePayload(data.message);
        if (streamPayload) {
          const h = document.createElement('h4');
          h.textContent = 'Message Schema';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(streamPayload, [], 0);
          container.appendChild(schemaEl);
        }
      }

      // JSON-RPC-specific
      if (activeProtocol === 'jsonrpc') {
        if (data['x-usd-notification'] || data['x-usd-streaming']) {
          const flags = [];
          if (data['x-usd-notification']) flags.push('notification');
          if (data['x-usd-streaming']) flags.push('streaming');
          const info = document.createElement('div');
          info.style.marginBottom = '16px';
          info.innerHTML = flags.map(f => '<span class="badge badge-rpc" style="margin-right: 6px;">' + esc(f) + '</span>').join('');
          container.appendChild(info);
        }
        appendContentTypes(
          container,
          'Content Types',
          resolveEffectiveContentTypes(data.contentTypes, jsonrpcSpec?.contentTypes)
        );
        if (data.params) {
          const h = document.createElement('h4');
          h.textContent = 'Parameters';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(data.params, data.params.required || [], 0);
          container.appendChild(schemaEl);
        }
        if (data.result) {
          const h = document.createElement('h4');
          h.textContent = 'Result';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(data.result, [], 0);
          container.appendChild(schemaEl);
        }
        if (Array.isArray(data.errors) && data.errors.length > 0) {
          const section = document.createElement('div');
          section.className = 'endpoint-subsection';
          section.innerHTML = '<div class="subsection-label">Errors</div>';
          data.errors.forEach((err) => {
            const card = document.createElement('div');
            card.className = 'info-card';
            card.innerHTML =
              '<div class="info-card-title">' + esc(err.code) + '</div>' +
              '<div class="info-card-value">' + esc(err.message) + '</div>' +
              (err.description ? '<div class="info-card-subtitle">' + esc(err.description) + '</div>' : '');
            section.appendChild(card);
            if (err.data) {
              const schemaEl = renderSchemaProperties(err.data, [], 0);
              section.appendChild(schemaEl);
            }
          });
          container.appendChild(section);
        }
      }

      // gRPC-specific
      if (activeProtocol === 'grpc') {
        const method = data.method;
        if (method) {
          const methodType = getGrpcMethodType(method);
          if (methodType && methodType !== 'unary') {
            const badge = document.createElement('span');
            badge.className = 'badge badge-stream';
            badge.textContent = methodType.replace('_', ' ');
            badge.style.marginBottom = '16px';
            badge.style.display = 'inline-block';
            container.appendChild(badge);
          }
          appendContentTypes(
            container,
            'Content Types',
            resolveEffectiveContentTypes(method.contentTypes, grpcSpec?.contentTypes)
          );
          if (method.input) {
            const h = document.createElement('h4');
            h.textContent = 'Request';
            container.appendChild(h);
            const schemaEl = renderSchemaProperties(method.input, [], 0);
            container.appendChild(schemaEl);
          }
          if (method.output) {
            const h = document.createElement('h4');
            h.textContent = 'Response';
            container.appendChild(h);
            const schemaEl = renderSchemaProperties(method.output, [], 0);
            container.appendChild(schemaEl);
          }
        }
      }

      // TCP-specific
      if (activeProtocol === 'tcp') {
        const grid = document.createElement('div');
        grid.className = 'info-grid';
        grid.innerHTML =
          '<div class="info-card"><div class="info-card-title">Host</div><div class="info-card-value">' +
          esc(data.host || 'localhost') + '</div></div>' +
          '<div class="info-card"><div class="info-card-title">Port</div><div class="info-card-value">' +
          (data.port || 'N/A') + '</div></div>' +
          (data.tls?.enabled ? '<div class="info-card"><div class="info-card-title">TLS</div><div class="info-card-value">Enabled</div></div>' : '');
        container.appendChild(grid);
        appendContentTypes(
          container,
          'Content Types',
          resolveEffectiveContentTypes(data.contentTypes, tcpSpec?.contentTypes)
        );
        if (data.framing) {
          const h = document.createElement('h4');
          h.textContent = 'Framing';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(data.framing, [], 0);
          container.appendChild(schemaEl);
        }
        if (data.messages?.inbound || data.messages?.outbound) {
          if (data.messages?.inbound) {
            const h = document.createElement('h4');
            h.textContent = 'Inbound Message';
            container.appendChild(h);
            const schemaEl = renderSchemaProperties(resolveMessagePayload(data.messages.inbound), [], 0);
            container.appendChild(schemaEl);
          }
          if (data.messages?.outbound) {
            const h = document.createElement('h4');
            h.textContent = 'Outbound Message';
            container.appendChild(h);
            const schemaEl = renderSchemaProperties(resolveMessagePayload(data.messages.outbound), [], 0);
            container.appendChild(schemaEl);
          }
        }
      }

      // UDP-specific
      if (activeProtocol === 'udp') {
        const grid = document.createElement('div');
        grid.className = 'info-grid';
        grid.innerHTML =
          '<div class="info-card"><div class="info-card-title">Host</div><div class="info-card-value">' +
          esc(data.host || '0.0.0.0') + '</div></div>' +
          '<div class="info-card"><div class="info-card-title">Port</div><div class="info-card-value">' +
          (data.port || 'N/A') + '</div></div>' +
          '<div class="info-card"><div class="info-card-title">Max Packet</div><div class="info-card-value">' +
          (data.maxPacketSize || 65507) + ' bytes</div></div>';
        container.appendChild(grid);
        appendContentTypes(
          container,
          'Content Types',
          resolveEffectiveContentTypes(data.contentTypes, udpSpec?.contentTypes)
        );
        if (data.messages?.inbound) {
          const h = document.createElement('h4');
          h.textContent = 'Inbound Message';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(resolveMessagePayload(data.messages.inbound), [], 0);
          container.appendChild(schemaEl);
        }
        if (data.messages?.outbound) {
          const h = document.createElement('h4');
          h.textContent = 'Outbound Message';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(resolveMessagePayload(data.messages.outbound), [], 0);
          container.appendChild(schemaEl);
        }
        if (!data.messages?.inbound && !data.messages?.outbound && data.message) {
          const h = document.createElement('h4');
          h.textContent = 'Message Schema';
          container.appendChild(h);
          const schemaEl = renderSchemaProperties(resolveMessagePayload(data.message), [], 0);
          container.appendChild(schemaEl);
        }
      }

      return container;
    }

    function getGrpcMethodType(method) {
      const client = method['x-usd-client-streaming'];
      const server = method['x-usd-server-streaming'];
      if (client && server) return 'bidirectional';
      if (client) return 'client_streaming';
      if (server) return 'server_streaming';
      return 'unary';
    }

    function resolveMessagePayload(message) {
      if (!message) return null;
      if (message.$ref) {
        const resolved = resolveRef(message.$ref);
        if (resolved && resolved.payload) return resolved.payload;
        return resolved || message;
      }
      if (message.payload) return message.payload;
      return message;
    }

    // Initial render
    renderProtocolTabs();
    renderSidebar();
    renderContent();
  `
}
